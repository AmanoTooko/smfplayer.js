{"version":3,"sources":["webpack://SMF/webpack/universalModuleDefinition","webpack://SMF/webpack/bootstrap","webpack://SMF/./src/midi_event.js","webpack://SMF/./src/mld.js","webpack://SMF/./src/player.js","webpack://SMF/./src/riff.js","webpack://SMF/./src/smf.js"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,mBAAmB;AAClC;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;;AAME;;;;;;;;;;;;;ACnFF;AAAA;AAAA;AACA;AACA;AACe;AACf;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,uBAAuB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,eAAe;AAChC;AACA,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,+BAA+B;AAC9C;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,0BAA0B;AACvC,cAAc;AACd;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,eAAe;AAChC;;AAEA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC73BA;AAAA;AAAA;AAAA;AAAwB;AACA;;AAExB;AACA;AACA;AACO;AACP;AACA,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB,wBAAwB;AACxB,eAAe,kBAAkB;AACjC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,yBAAyB;AACxC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,cAAc;AAC3B;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,SAAS,YAAY,EAAE;AACtC;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,gBAAgB;AACjC;AACA,iBAAiB,EAAE;AACnB;AACA,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA,eAAe,IAAI;AACnB,uBAAuB,4CAAG;;AAE1B;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA,eAAe,IAAI;AACnB,uBAAuB,4CAAG;;AAE1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,+BAA+B;AAC9C;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA,mCAAmC,QAAQ;AAC3C;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACplBA;AAAA;AAAA;AACA;AACA;AACe;AACf;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,kBAAkB;AACjC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,eAAe,UAAU;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;;;;;;;;;;;;;AChHA;AAAA;AAAA;AAAA;AAA0B;AAKJ;;AAEtB;AACA;AACA;AACe;AACf;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC;AACA;;AAEA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA,cAAc;AACd;AACA;AACA,2BAA2B,6CAAI;;AAE/B;;AAEA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,2BAA2B;AAC1C;AACA,eAAe,0BAA0B;AACzC;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,EAAE,4CAA4C;AAC7D;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,EAAE,4CAA4C;AAC7D;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,MAAM;AACrB;AACA,eAAe,UAAU;AACzB;;AAEA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAY;AAClC;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAY;AACrC;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"smf.player.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SMF\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SMF\"] = factory();\n\telse\n\t\troot[\"SMF\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/player.js\");\n","/**\n * Midi Event abstract class\n */\nclass Event {\n  /**\n   * @param {string} subtype event subtype name.\n   * @param {number} deltaTime delta time.\n   * @param {number} time time.\n   */\n  constructor(subtype, deltaTime, time) {\n    /** @type {string} */\n    this.subtype = subtype;\n    /** @type {number} */\n    this.deltaTime = deltaTime;\n    /** @type {number} */\n    this.time = time;\n  }\n}\n\n/**\n * Midi Channel Event Class\n * @extends {Event}\n */\nclass ChannelEvent extends Event {\n  /**\n   * @param {string} subtype\n   * @param {number} deltaTime delta time.\n   * @param {number} time time.\n   * @param {number} channel\n   * @param {number=} optParameter1\n   * @param {number=} optParameter2\n   */\n  constructor(subtype, deltaTime, time, channel, optParameter1, optParameter2) {\n    super(subtype, deltaTime, time);\n    /** @type {number} */\n    this.channel = channel;\n    /** @type {(number|undefined)} */\n    this.parameter1 = optParameter1;\n    /** @type {(number|undefined)} */\n    this.parameter2 = optParameter2;\n  }\n}\n\n/**\n * System Exclusive Event Class\n * @extends {Event}\n */\nclass SystemExclusiveEvent extends Event {\n  /**\n   * @param {string} subtype\n   * @param {number} deltaTime delta time.\n   * @param {number} time time.\n   * @param {ByteArray} data\n   */\n  constructor(subtype, deltaTime, time, data) {\n    super(subtype, deltaTime, time);\n    /** @type {ByteArray} */\n    this.data = data;\n  }\n}\n\n/**\n * Midi Meta Event Class\n * @extends {Event}\n */\nclass MetaEvent extends Event {\n  /**\n   * @param {string} subtype\n   * @param {number} deltaTime delta time.\n   * @param {number} time time.\n   * @param {Array.<*>} data meta data.\n   */\n  constructor(subtype, deltaTime, time, data) {\n    super(subtype, deltaTime, time);\n    /** @type {Array.<*>} */\n    this.data = data;\n  };\n}\n\nexport {\n  ChannelEvent,\n  SystemExclusiveEvent,\n  MetaEvent,\n};\n","/**\n * Mld Parser Class\n */\nexport default class Mld {\n  /**\n   * @param {ByteArray} input\n   * @param {Object=} optParams\n   */\n  constructor(input, optParams = {}) {\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {number} */\n    this.ip = optParams.index || 0;\n    /** @type {Object} */\n    this.header;\n    /** @type {Object} */\n    this.dataInformation;\n    /** @type {Array.<Array.<Object>>} */\n    this.tracks;\n  };\n\n  /**\n   */\n  parse() {\n    this.parseHeader();\n    this.parseDataInformation();\n    this.parseTracks();\n  };\n\n  /**\n   */\n  parseHeader() {\n    /** @type {ByteArray} */\n    const input = this.input;\n    /** @type {number} */\n    let ip = this.ip;\n    /** @type {Object} */\n    const header = this.header = {};\n    /** @type {string} */\n    const signature =\n      String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]);\n\n    if (signature !== 'melo') {\n      throw new Error('invalid MFi signature:' + signature);\n    }\n\n    header.fileLength = (\n      (input[ip++] << 24) | (input[ip++] << 16) |\n      (input[ip++] << 8) | input[ip++]\n    ) >>> 0;\n\n    header.trackOffset = (\n      (input[ip++] << 16) | input[ip++]\n    ) + ip;\n\n    header.dataMajorType = input[ip++];\n    header.dataMinorType = input[ip++];\n    header.numberOfTracks = input[ip++];\n\n    this.ip = ip;\n  };\n\n  /**\n   */\n  parseDataInformation() {\n    /** @type {ByteArray} */\n    const input = this.input;\n    /** @type {number} */\n    let ip = this.ip;\n    /** @type {Object} */\n    const dataInformation = this.dataInformation = {\n      'copy': null,\n      'date': null,\n      'exst': null,\n      'note': null,\n      'prot': null,\n      'sorc': null,\n      'titl': null,\n      'trac': null,\n      'vers': null,\n    };\n    /** @type {string} */\n    let type;\n    /** @type {number} */\n    let size;\n\n    while (ip < this.header.trackOffset) {\n      type =\n        String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]);\n      size = (input[ip++] << 8) | input[ip++];\n\n      switch (type) {\n        case 'titl':\n        /* FALLTHROUGH */\n        case 'copy':\n        /* FALLTHROUGH */\n        case 'vers':\n        /* FALLTHROUGH */\n        case 'date':\n        /* FALLTHROUGH */\n        case 'prot':\n          dataInformation[type] = String.fromCharCode.apply(\n            null,\n            input.subarray(ip, ip += size)\n          );\n          break;\n        case 'sorc':\n          dataInformation[type] = input[ip++];\n          break;\n        case 'note':\n          dataInformation[type] = (input[ip++] << 8) | input[ip++];\n          break;\n        case 'exst':\n          /* FALLTHROUGH */\n          break;\n        default:\n          dataInformation[type] = input.subarray(ip, ip += size);\n          break;\n      }\n    }\n\n    this.ip = ip;\n  }\n\n  /**\n   */\n  parseTracks() {\n    /** @type {ByteArray} */\n    const input = this.input;\n    /** @type {number} */\n    let ip = this.ip;\n    /** @type {string} */\n    let signature;\n    /** @type {number} */\n    let size;\n    /** @type {number} */\n    let limit;\n    /** @type {number} */\n    let status;\n    /** @type {number} */\n    let extendStatus;\n    /** @type {Object} */\n    let message;\n    /** @type {Array.<Array.<Object>>} */\n    const tracks = this.tracks = [];\n    /** @type {Array.<Object>} */\n    let track;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /**\n     * @return {Array.<Object>}\n     */\n    const parseEditInstrument = () => {\n      /** @type {number} */\n      const length = (input[ip++] << 8) | input[ip++];\n      /** @type {number} */\n      const limit = ip + length;\n      /** @type {Array.<Object>} */\n      const result = [];\n      /** @type {Object} */\n      let info;\n\n      // const\n      if (input[ip++] !== 1) {\n        throw new Error('invalid EditInstrument const value:' + input[ip - 1]);\n      }\n\n      while (ip < limit) {\n        info = {};\n\n        info['part'] = (input[ip++] >> 4) & 0x3;\n        info['modulator'] = {\n          'ML': input[ip] >> 5,\n          'VIV': (input[ip] >> 4) & 0x1,\n          'EG': (input[ip] >> 3) & 0x1,\n          'SUS': (input[ip] >> 2) & 0x1,\n          'RR': ((input[ip++] & 0x3) << 2) | (input[ip] >> 6),\n          'DR': (input[ip] >> 4) & 0xf,\n          'AR': ((input[ip++] & 0x3) << 2) | (input[ip] >> 6),\n          'SL': (input[ip] >> 4) & 0xf,\n          'TL': ((input[ip++] & 0x3) << 4) | (input[ip] >> 4),\n          'WF': (input[ip] >> 3) & 0x1,\n          'FB': input[ip++] & 0x7,\n        };\n        info['carrier'] = {\n          'ML': input[ip] >> 5,\n          'VIV': (input[ip] >> 4) & 0x1,\n          'EG': (input[ip] >> 3) & 0x1,\n          'SUS': (input[ip] >> 2) & 0x1,\n          'RR': ((input[ip++] & 0x3) << 2) | (input[ip] >> 6),\n          'DR': (input[ip] >> 4) & 0xf,\n          'AR': ((input[ip++] & 0x3) << 2) | (input[ip] >> 6),\n          'SL': (input[ip] >> 4) & 0xf,\n          'TL': ((input[ip++] & 0x3) << 4) | (input[ip] >> 4),\n          'WF': (input[ip] >> 3) & 0x1,\n          'FB': input[ip++] & 0x7,\n        };\n        info['octaveSelect'] = input[ip++] & 0x3;\n\n        result.push(info);\n      }\n\n      return result;\n    };\n    /**\n     * @return {{part: number, switch: number}}\n     */\n    const parseVibrato = () => {\n      // const\n      if (input[ip++] !== 1) {\n        throw new Error('invalid Vibrato const value:' + input[ip - 1]);\n      }\n\n      return {\n        'part': (input[ip++] >> 5) & 0x3,\n        'switch': (input[ip++] >> 6),\n      };\n    };\n    /**\n     * @return {{data: ByteArray}}\n     */\n    const parseDeviceSpecific = () => {\n      /** @type {number} */\n      const length = (input[ip++] << 8) | input[ip++];\n      /** @type {number} */\n      const limit = ip + length;\n\n      // const\n      if (input[ip++] !== 0x11) {\n        throw new Error('invalid DeviceSpecific const value:' + input[ip - 1]);\n      }\n\n      return {\n        'data': input.subarray(ip, ip += limit - ip),\n      };\n    };\n\n    for (i = 0, il = this.header.numberOfTracks; i < il; ++i) {\n      signature =\n        String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]);\n\n      if (signature !== 'trac') {\n        throw new Error('invalid track signature:' + signature);\n      }\n\n      size =\n        (input[ip++] << 24) | (input[ip++] << 16) |\n        (input[ip++] << 8) | input[ip++];\n\n      limit = ip + size;\n\n      track = tracks[i] = [];\n\n      while (ip < limit) {\n        message = {\n          key: null,\n          length: null,\n          octaveShift: null,\n          subType: null,\n          type: null,\n          value: {},\n          velocity: null,\n          voice: null,\n        };\n\n        // delta time\n        message.deltaTime = deltaTime = input[ip++];\n\n        // status\n        status = input[ip++];\n        if (status !== 0xff) {\n          message.type = 'note';\n          message.subType = 'Note';\n          message.voice = status >> 6;\n          message.key = status & 0x3f;\n\n          // note length\n          noteLength = message.length = input[ip++];\n\n          // extend status\n          if (this.dataInformation.note === 1) {\n            extendStatus = input[ip++];\n            message.velocity = extendStatus >> 2;\n            message.octaveShift = extendStatus & 0x3;\n          }\n        } else {\n          message.type = 'meta';\n\n          // status\n          status = input[ip++];\n          switch (status >> 4) {\n            // system message\n            case 0xb:\n              switch (status & 0xf) {\n                case 0x0:\n                  message.subType = 'MasterVolume';\n                  message.value = input[ip++];\n                  break;\n                case 0xa:\n                  message.subType = 'DrumScale';\n                  message.value = {\n                    'channel': (input[ip] >> 3) & 0x7,\n                    'drum': input[ip++] & 0x1,\n                  };\n                  break;\n                default:\n                  throw new Error('unknown message type:' + status.toString(16));\n              }\n              break;\n            // tempo message\n            case 0xc:\n              message.subType = 'SetTempo';\n              message.value = {\n                'timeBase': (status & 0x7) === 7 ?\n                  NaN : Math.pow(2, status & 0x7) * ((status & 0x8) === 0 ? 6 : 15),\n                'tempo': input[ip++],\n              };\n              break;\n            // control message\n            case 0xd:\n              switch (status & 0xf) {\n                case 0x0:\n                  message.subType = 'Point';\n                  message.value = input[ip++];\n                  break;\n                case 0xd:\n                  message.subType = 'Loop';\n                  message.value = {\n                    'id': input[ip] >> 6,\n                    'count': input[ip] >> 2 & 0xf,\n                    'point': input[ip++] & 0x3,\n                  };\n                  break;\n                case 0xe:\n                  message.subType = 'Nop';\n                  message.value = input[ip++];\n                  break;\n                case 0xf:\n                  message.subType = 'EndOfTrack';\n                  message.value = input[ip++];\n                  break;\n                default:\n                  throw new Error('unkwnon message type:' + status.toString(16));\n              }\n              break;\n            // instrument\n            case 0xe:\n              switch (status & 0xf) {\n                case 0x0:\n                  message.subType = 'InstrumentLowPart';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'instrument': input[ip++] & 0x3f,\n                  };\n                  break;\n                case 0x1:\n                  message.subType = 'InstrumentHighPart';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'instrument': input[ip++] & 0x1,\n                  };\n                  break;\n                case 0x2:\n                  message.subType = 'Volume';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'volume': input[ip++] & 0x3f,\n                  };\n                  break;\n                case 0x3:\n                  message.subType = 'Valance';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'valance': input[ip++] & 0x3f,\n                  };\n                  break;\n                case 0x4:\n                  message.subType = 'PitchBend';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'value': input[ip++] & 0x3f,\n                  };\n                  break;\n                case 0x5:\n                  message.subType = 'ChannelAssign';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'channel': input[ip++] & 0x3f,\n                  };\n                  break;\n                case 0x6:\n                  message.subType = 'VolumeChange';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'volume': (input[ip++] & 0x3f) << 26 >> 26,\n                  };\n                  break;\n                case 0x7:\n                  message.subType = 'PitchBendRange';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'value': (input[ip++] & 0x3f),\n                  };\n                  break;\n\n\n                case 0x8:\n                /*\n                // TODO: 未遭遇\n                message.subType = 'MasterFineTuning';\n                message.value = {\n                  'part': input[ip] >> 6,\n                  'value': (input[ip++] & 0x3f)\n                };\n                break;\n                */\n                // TODO: あってるか自信ない\n                case 0x9:\n                  message.subType = 'MasterCoarseTuning';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'value': (input[ip++] & 0x3f),\n                  };\n                  break;\n                case 0xA:\n                  message.subType = 'Modulation';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'depth': (input[ip++] & 0x3f),\n                  };\n                  break;\n                default:\n                  throw new Error('unkwnon message type:' + status.toString(16));\n              }\n              break;\n            // extended information\n            case 0xf:\n              switch (status & 0xf) {\n                case 0x0:\n                  message.subType = 'EditInstrument';\n                  message.value = parseEditInstrument();\n                  break;\n                case 0x1:\n                  message.subType = 'Vibrato';\n                  message.value = parseVibrato();\n                  break;\n                case 0xf:\n                  message.subType = 'DeviceSpecific';\n                  message.value = parseDeviceSpecific();\n                  break;\n                default:\n                  throw new Error('unkwnon message type:' + status.toString(16));\n              }\n              break;\n            default:\n              throw new Error('unkwnon message type:' + status.toString(16));\n          }\n        }\n\n        track.push(message);\n      }\n      ip = limit;\n    }\n\n    this.ip = ip;\n  }\n\n  /**\n   * @return {Object}\n   */\n  convertToMidiTracks() {\n    /** @type {Object} */\n    const result = {\n      timeDivision: 48,\n      trac: [],\n      plainTracks: [],\n    };\n    /** @type {Array.<Array.<Object>>} */\n    const tracks = result.tracks;\n    /** @type {Array.<Array.<Array.<number>>>} */\n    const plainTracks = result.plainTracks;\n    /** @type {Array.<Array.<Object>>} */\n    const mfiTracks = this.tracks;\n    /** @type {Array.<Object>} */\n    let mfiTrack;\n    /** @type {Object} */\n    let mfiEvent;\n    /** @type {Object} */\n    let prevEvent;\n    /** @type {Array.<Object>} */\n    let tmpTrack;\n    /** @type {number} */\n    let time;\n    /** @type {number} */\n    let pos;\n    /** @type {number} */\n    let key;\n    /** @type {number} */\n    let tmp;\n    /** @type {string} */\n    let str;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let jl;\n    /** @type {Array.<number>} */\n    const channelTime = [];\n    /** @type {number} */\n    let channel;\n\n    for (i = 0; i < 16; ++i) {\n      plainTracks[i] = [];\n      channelTime[i] = 0;\n    }\n\n    // 変換しにくい形式を平坦化する\n    for (i = 0, il = mfiTracks.length; i < il; ++i) {\n      mfiTrack = mfiTracks[i];\n      tmpTrack = [];\n\n      // note の処理\n      for (time = pos = j = 0, jl = mfiTrack.length; j < jl; ++j) {\n        mfiEvent = mfiTrack[j];\n        time += mfiEvent['deltaTime'];\n        mfiEvent['id'] = pos;\n        mfiEvent['time'] = time;\n\n        switch (mfiEvent['subType']) {\n          case 'Nop':\n            break;\n          case 'Note':\n            tmpTrack[pos++] = mfiEvent;\n            // TODO: value: ... 形式になおす\n            tmpTrack[pos] = {\n              'id': pos,\n              'type': 'internal',\n              'subType': 'NoteOff',\n              'time': time + mfiEvent['length'],\n              'key': mfiEvent['key'],\n              'voice': mfiEvent['voice'],\n              'velocity': mfiEvent['velocity'],\n              'octaveShift': mfiEvent['octaveShift'],\n            };\n            pos++;\n            break;\n          case 'InstrumentHighPart':\n            prevEvent = mfiEvent;\n            mfiEvent = mfiTrack[++j];\n            if (mfiEvent['subType'] !== 'InstrumentLowPart') {\n              throw new Error('broken instrument');\n            }\n            // TODO: value: ... 形式になおす\n            tmpTrack[pos] = {\n              'id': pos,\n              'type': 'internal',\n              'subType': 'ProgramChange',\n              'time': time,\n              'part': mfiEvent['value']['part'],\n              'instrument': (prevEvent['value']['instrument'] << 6) | mfiEvent['value']['instrument'],\n            };\n            pos++;\n            break;\n          default:\n            tmpTrack[pos++] = mfiEvent;\n            break;\n        }\n      }\n      tmpTrack.sort((a, b) => {\n        return a['time'] > b['time'] ? 1 : a['time'] < b['time'] ? -1 :\n          a['id'] > b['id'] ? 1 : a['id'] < b['id'] ? -1 :\n            0;\n      });\n\n      // MIDI トラックに作成\n      tracks[i] = [];\n      for (time = j = 0, jl = tmpTrack.length; j < jl; ++j) {\n        mfiEvent = tmpTrack[j];\n        time = mfiEvent['time'];\n\n        switch (mfiEvent['subType']) {\n          case 'Note':\n            // NoteOn: 9n kk vv\n            key = this.applyOctaveShift(mfiEvent['key'] + 45, mfiEvent['octaveShift']);\n            channel = i * 4 + mfiEvent['voice'];\n\n            // TODO: リズムトラックの時は Key が -10 されているような気がする\n            if (channel === 9) {\n              key -= 10;\n            }\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0x90 | channel,\n                key,\n                mfiEvent['velocity'] * 2\n              )\n            );\n            break;\n          case 'NoteOff':\n            // NoteOff: 8n kk vv\n            key = this.applyOctaveShift(mfiEvent['key'] + 45, mfiEvent['octaveShift']);\n            channel = i * 4 + mfiEvent['voice'];\n\n            // TODO: リズムトラックの時は Key が -10 されているような気がする\n            if (channel === 9) {\n              key -= 10;\n            }\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0x80 | channel,\n                key,\n                mfiEvent['velocity'] * 2\n              )\n            );\n            break;\n          case 'ProgramChange':\n            // Program Change: Cn pp\n            channel = i * 4 + mfiEvent['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xC0 | channel,\n                mfiEvent['instrument']\n              )\n            );\n            break;\n          case 'SetTempo':\n            // SetTempo: FF 51 03 tt tt tt\n            tmp = 2880000000 / (mfiEvent['value']['tempo'] * mfiEvent['value']['timeBase']);\n            channel = 0; // SetTempo は必ず先頭のトラックに配置する\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xFF,\n                0x51,\n                0x03,\n                (tmp >> 16) & 0xff, (tmp >> 8) & 0xff, tmp & 0xff\n              )\n            );\n            break;\n          case 'Loop':\n            // Marker: FF 06 ll ss ss ss ...\n            tmp = mfiEvent['value']['count'];\n            str = 'LOOP_' +\n              (mfiEvent['value']['point'] === 0 ? 'START' : 'END') +\n              '=ID:' + mfiEvent['value']['id'] +\n              ',COUNT:' + (tmp === 0 ? -1 : tmp);\n            channel = 0;\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                [\n                  0xFF,\n                  0x06,\n                  str.length,\n                ],\n                str.split('').map((a) => {\n                  return a.charCodeAt(0);\n                })\n              )\n            );\n            break;\n          case 'MasterVolume':\n            // Master Volume: F0 7F ee 04 01 dl dm F7\n            tmp = mfiEvent['value'];\n            channel = 0;\n\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xF0,\n                0x07, // length\n                0x7F, 0x7F, 0x04, 0x01, tmp, tmp, 0xF7\n              )\n            );\n            break;\n          case 'Modulation':\n            // CC#1 Modulation: Bn 01 dd\n            channel = i * 4 + mfiEvent['value']['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xB0 | channel,\n                0x01,\n                mfiEvent['value']['depth'] * 2\n              )\n            );\n            break;\n          case 'Volume':\n            // CC#7 Volume: Bn 07 dd\n            channel = i * 4 + mfiEvent['value']['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xB0 | channel,\n                0x07,\n                mfiEvent['value']['volume'] * 2\n              )\n            );\n            break;\n          case 'Valance':\n            // CC#10 Panpot: Bn 0A dd\n            channel = i * 4 + mfiEvent['value']['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xB0 | channel,\n                0x0A,\n                (mfiEvent['value']['valance'] - 32) * 2 + 64\n              )\n            );\n            break;\n          case 'PitchBend':\n            // Pitch Bend: En dl dm\n            // TODO: LSB = MSB で良いか不明\n            channel = i * 4 + mfiEvent['value']['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xE0 | channel,\n                mfiEvent['value']['value'] * 2,\n                mfiEvent['value']['value'] * 2\n              )\n            );\n            break;\n          case 'PitchBendRange':\n            // Pitch Bend: CC#100=0 CC#101=0 CC#6\n            // Bn 64 00 Bn 65 00 Bn 06 vv\n            channel = i * 4 + mfiEvent['value']['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xB0 | channel,\n                0x64, 0x00\n              ), [\n                0x00,\n                0xB0 | channel,\n                0x65, 0x00,\n              ], [\n                0x00,\n                0xB0 | channel,\n                0x06, mfiEvent['value']['value'] * 2,\n              ]\n            );\n            break;\n          case 'MasterCoarseTuning':\n            // MasterCoarseTuning: CC#100=0 CC#101=2 CC#6\n            // Bn 64 01 Bn 65 02 Bn 06 vv\n            channel = i * 4 + mfiEvent['value']['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xB0 | channel,\n                0x64, 0x00\n              ), [\n                0x00,\n                0xB0 | channel,\n                0x65, 0x02,\n              ], [\n                0x00,\n                0xB0 | channel,\n                0x06, mfiEvent['value']['value'] * 2,\n              ]\n            );\n            break;\n          default:\n            continue;\n        }\n\n        channelTime[channel] = mfiEvent['time'];\n      }\n    }\n\n    return this.toSMF(plainTracks);\n  }\n\n  /**\n   * @param {number} key\n   * @param {number} octaveShift\n   * @return {number}\n   */\n  applyOctaveShift(key, octaveShift) {\n    /** @type {Array.<number>} */\n    const table = [0, 12, -24, -12];\n\n    if (table[octaveShift] !== void 0) {\n      return key + table[octaveShift];\n    }\n\n    throw new Error('invalid OctaveShift value:' + octaveShift);\n  }\n\n  /**\n   * @param {Array.<Array.<ByteArray>>} plainTracks\n   * @return {ByteArray}\n   */\n  toSMF(plainTracks) {\n    /** @type {number} @const */\n    const TimeDivision = 48;\n    /** @type {Array.<number>} */\n    let trackHeader;\n    /** @type {Array.<number>} */\n    let trackData;\n    /** @type {ByteArray} */\n    let result = [\n      0x4D, 0x54, 0x68, 0x64, // \"MThd\"\n      0x00, 0x00, 0x00, 0x06, // Size\n      0x00, 0x01, // Format\n      0x00, 0x10, // number of track\n      (TimeDivision >> 8) & 0xff, TimeDivision & 0xff, // Data\n    ];\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let jl;\n\n    /**\n     * @param {string} str\n     * @return {Array.<number>}\n     */\n    function stringToArray(str) {\n      /** @type {number} */\n      let i;\n      /** @type {number} */\n      const il = str.length;\n      /** @type {Array.<number>} */\n      const array = new Array(il);\n\n      for (i = 0; i < il; ++i) {\n        array[i] = str.charCodeAt(i);\n      }\n\n      return array;\n    }\n\n    if (this.dataInformation['copy'] !== void 0) {\n      /** @type {Array.<number>} */\n      let copy = stringToArray(this.dataInformation['copy']);\n\n      il = copy.length;\n      copy = [0x00, 0xff, 0x02].concat(\n        this.deltaTimeToByteArray(il),\n        copy\n      );\n      plainTracks[0].unshift(copy);\n    }\n\n    /*\n    if (this.dataInformation['titl'] !== void 0) {\n      let title = stringToArray(this.dataInformation['titl']);\n      il = title.length;\n      title = [0x00, 0xff, 0x03].concat(\n        this.deltaTimeToByteArray(il),\n        title\n      );\n      plainTracks[0].unshift(title);\n    }\n    */\n\n    for (i = 0, il = plainTracks.length; i < il; ++i) {\n      const track = plainTracks[i];\n      trackData = [];\n      for (j = 0, jl = track.length; j < jl; ++j) {\n        Array.prototype.push.apply(trackData, track[j]);\n      }\n\n      jl = trackData.length;\n      trackHeader = [\n        0x4D, 0x54, 0x72, 0x6B, // \"MTrk\"\n        (jl >> 24) & 0xff, (jl >> 16) & 0xff,\n        (jl >> 8) & 0xff, (jl) & 0xff,\n      ];\n      result = result.concat(trackHeader, trackData);\n    }\n\n    return new Uint8Array(result);\n  }\n\n  /**\n   * @param {number} deltaTime\n   * @return {Array.<number>}\n   */\n  deltaTimeToByteArray(deltaTime) {\n    /** @type {Array.<number>} */\n    const array = [];\n\n    while (deltaTime >= 0x80) {\n      array.unshift(deltaTime & 0x7f | (array.length === 0 ? 0 : 0x80));\n      deltaTime >>>= 7;\n    }\n    array.unshift(deltaTime | (array.length === 0 ? 0 : 0x80));\n\n    return array;\n  }\n}\n","import SMF from './smf';\nimport Mld from './mld';\n\n/**\n * Midi Player Class\n */\nexport class Player {\n  /**\n   * @param {string} target WML attach dom\n   */\n  constructor(target = '#wml') {\n    /** @type {number} */\n    this.tempo = 500000; // default\n    /** @type {HTMLIFrameElement} */\n    this.webMidiLink;\n    /** @type {number} */\n    this.resume;\n    /** @type {boolean} */\n    this.pause = true;\n    /** @type {boolean} */\n    this.ready = false;\n    /** @type {number} */\n    this.position = 0;\n    /** @type {Array.<Object>} */\n    this.track = [];\n    /** @type {number} */\n    this.timer = 0;\n    /** @type {Object} TODO: 最低限のプロパティは記述する */\n    this.sequence = {};\n    /** @type {boolean} */\n    this.enableCC111Loop = false;\n    /** @type {boolean} */\n    this.enableFalcomLoop = false;\n    /** @type {boolean} */\n    this.enableMFiLoop = false;\n    /** @type {boolean} */\n    this.enableLoop = false;\n    /** @type {number} */\n    this.tempoRate = 1;\n    /** @type {number} */\n    this.masterVolume = 16383;\n    /** @type {?string} */\n    this.sequenceName = '';\n    /** @type {Array.<string>} */\n    this.copyright = [];\n    /** @type {HTMLIFrameElement|Worker} */\n    this.webMidiLink = null;\n    /** @type {number} */\n    this.length = 0;\n    /** @type {number} */\n    this.time = 0;\n    /** @type {number} */\n    this.timeTotal;\n    /** @type {number} */\n    this.loaded = 0;\n    /** @type {Window} */\n    this.window = window;\n    /** @type {Element} */\n    this.target = this.window.document.querySelector(target);\n  }\n\n  /**\n   * @param {boolean} enable\n   */\n  setCC111Loop(enable) {\n    this.enableCC111Loop = enable;\n  }\n\n  /**\n   * @param {boolean} enable\n   */\n  setFalcomLoop(enable) {\n    this.enableFalcomLoop = enable;\n  }\n\n  /**\n   * @param {boolean} enable\n   */\n  setMFiLoop(enable) {\n    this.enableMFiLoop = enable;\n  }\n\n  /**\n   * @param {boolean} enable\n   */\n  setLoop(enable) {\n    this.enableLoop = enable;\n  }\n\n  /**\n   */\n  stop() {\n    /** @type {number} */\n    let i;\n\n    this.pause = true;\n    this.resume = Date.now();\n\n    if (this.webMidiLink) {\n      for (i = 0; i < 16; ++i) {\n        this.webMidiLink.contentWindow.postMessage('midi,b' + i.toString(16) + ',78,0', '*');\n      }\n    }\n  }\n\n  /**\n   * @return {HTMLIframeElement}\n   */\n  getWebMidiLink() {\n    return this.webMidiLink;\n  }\n\n  /**\n   */\n  init() {\n    this.stop();\n    this.initSequence();\n    this.pause = true;\n    this.track = null;\n    this.resume = -1;\n    this.sequence = null;\n    this.sequenceName = null;\n    this.copyright = null;\n    this.length = 0;\n    this.position = 0;\n    this.time = 0;\n    this.timeTotal = 0;\n\n    this.window.clearTimeout(this.timer);\n\n    /** @type {Player} */\n    const player = this;\n    if (this.ready) {\n      this.sendInitMessage();\n    } else {\n      this.window.addEventListener('message', (ev) => {\n        if (ev.data === 'link,ready') {\n          player.sendInitMessage();\n        }\n      }, false);\n    }\n  };\n\n  /**\n   */\n  initSequence() {\n    this.tempo = 500000;\n    this.position = 0;\n\n    this.sendInitMessage();\n    this.pause = false;\n  }\n\n  /**\n   */\n  play() {\n    /** @type {Player} */\n    const player = this;\n\n    if (!this.webMidiLink) {\n      throw new Error('WebMidiLink not found');\n    }\n\n    if (this.ready) {\n      if (this.track) {\n        this.length = this.track.length;\n        if (this.track instanceof Array && this.position >= this.length) {\n          this.position = 0;\n        }\n        this.playSequence();\n      } else {\n        console.warn('Midi file is not loaded.');\n      }\n    } else {\n      this.window.addEventListener('message', (ev) => {\n        if (ev.data === 'link,ready') {\n          player.ready = true;\n          player.playSequence();\n        }\n      }, false);\n    }\n  };\n\n  /**\n   */\n  ended() {\n    player.window.postMessage('endoftrack', '*');\n  }\n\n  /**\n   */\n  sendInitMessage() {\n    /** @type {Window} */\n    const win = this.webMidiLink.contentWindow;\n    /** @type {number} */\n    let i;\n\n    for (i = 0; i < 16; ++i) {\n      // all sound off\n      win.postMessage('midi,b' + i.toString(16) + ',128,0', '*');\n      // volume\n      win.postMessage('midi,b' + i.toString(16) + ',07,64', '*');\n      // panpot\n      win.postMessage('midi,b' + i.toString(16) + ',0a,40', '*');\n      // pitch bend\n      win.postMessage('midi,e' + i.toString(16) + ',00,40', '*');\n      // pitch bend range\n      win.postMessage('midi,b' + i.toString(16) + ',64,00', '*');\n      win.postMessage('midi,b' + i.toString(16) + ',65,00', '*');\n      win.postMessage('midi,b' + i.toString(16) + ',06,02', '*');\n      win.postMessage('midi,b' + i.toString(16) + ',26,00', '*');\n    }\n    this.sendGmReset();\n  };\n\n  /**\n   * @param {string|Worker} port WebMidiLink url.\n   */\n  setWebMidiLink(port = './wml.html') {\n    /** @type {Player} */\n    const player = this;\n\n    const process = (ev) => {\n      if (typeof ev.data === 'string') {\n        const msg = ev.data.split(',');\n\n        if (msg[0] === 'link') {\n          // console.log(ev.data);\n          if (msg[1] === 'ready') {\n            player.ready = true;\n            player.loaded = 100;\n            player.setMasterVolume(player.masterVolume);\n          } else if (msg[1] === 'progress') {\n            // console.log(msg[2]);\n            player.loaded = Math.round((msg[2] / msg[3]) * 10000);\n          }\n        }\n      }\n    };\n\n    if (typeof port === 'string') {\n      // Clear self\n      if (this.webMidiLink) {\n        this.webMidiLink.parentNode.removeChild(this.webMidiLink);\n      }\n\n      // Clear parent DOM\n      if (this.target.firstChild) {\n        this.target.removeChild(this.target.firstChild);\n      }\n\n      /** @type {HTMLIFrameElement} */\n      const iframe = this.webMidiLink =\n        /** @type {HTMLIFrameElement} */\n        (this.window.document.createElement('iframe'));\n      iframe.src = port;\n      iframe.className = 'wml';\n\n      this.target.appendChild(iframe);\n      this.window.addEventListener('message', process, false);\n    } else {\n      // Worker Mode\n      this.webMidiLink.addEventListener('message', process, false);\n    }\n  };\n\n  /**\n   * @param {number} volume\n   */\n  setMasterVolume(volume) {\n    this.masterVolume = volume;\n\n    if (this.webMidiLink) {\n      this.webMidiLink.contentWindow.postMessage(\n        'midi,f0,7f,7f,04,01,' + [\n          ('0' + ((volume) & 0x7f).toString(16)).substr(-2),\n          ('0' + ((volume >> 7) & 0x7f).toString(16)).substr(-2),\n          '7f',\n        ].join(','),\n        '*'\n      );\n    }\n  };\n\n  /**\n   * @param {number} tempo\n   */\n  setTempoRate(tempo) {\n    this.tempoRate = tempo;\n  };\n\n  /**\n   */\n  playSequence() {\n    /** @type {Player} */\n    const player = this;\n    /** @type {number} */\n    const timeDivision = this.sequence.timeDivision;\n    /** @type {Array.<Object>} */\n    const mergedTrack = this.track;\n    /** @type {Window} */\n    const webMidiLink = this.webMidiLink.contentWindow;\n    /** @type {number} */\n    let pos = this.position || 0;\n    /** @type {Array.<?{pos: number}>} */\n    const mark = [];\n\n    const update = () => {\n      /** @type {number} */\n      const time = mergedTrack[pos]['time'];\n      /** @type {number} */\n      const length = mergedTrack.length;\n      /** @type {Object} TODO */\n      let event;\n      /** @type {?Array.<string>} */\n      let match;\n      /** @type {*} */\n      let tmp;\n      /** @type {number} */\n      let procTime = Date.now();\n\n      if (player.pause) {\n        player.resume = Date.now() - player.resume;\n        return;\n      }\n\n      do {\n        event = mergedTrack[pos]['event'];\n\n        // set tempo\n        if (event.subtype === 'SetTempo') {\n          player.tempo = event.data[0];\n        }\n\n        // CC#111 Loop\n        if (event.subtype === 'ControlChange' && event.parameter1 === 111) {\n          mark[0] = {\n            'pos': pos,\n          };\n        }\n\n        // Ys Eternal 2 Loop\n        if (event.subtype === 'Marker') {\n          // mark\n          if (event.data[0] === 'A') {\n            mark[0] = {\n              'pos': pos,\n            };\n          }\n          // jump\n          if (event.data[0] === 'B' && player.enableFalcomLoop &&\n            mark[0] && typeof mark[0]['pos'] === 'number') {\n            pos = mark[0]['pos'];\n            player.timer = player.window.setTimeout(update, 0);\n            player.position = pos;\n            return;\n          }\n        }\n\n        // MFi Loop\n        if (event.subtype === 'Marker') {\n          // mark\n          match =\n            event.data[0].match(/^LOOP_(START|END)=ID:(\\d+),COUNT:(-?\\d+)$/);\n          if (match) {\n            if (match[1] === 'START') {\n              mark[match[2] | 0] = mark[match[2]] || {\n                'pos': pos,\n                'count': match[3] | 0,\n              };\n            } else if (match[1] === 'END' && player.enableMFiLoop) {\n              tmp = mark[match[2] | 0];\n              if (tmp['count'] !== 0) { // loop jump\n                if (tmp['count'] > 0) {\n                  tmp['count']--;\n                }\n                pos = tmp['pos'];\n                player.timer = player.window.setTimeout(update, 0);\n                player.position = pos;\n                return;\n              } else { // loop end\n                mark[match[2] | 0] = null;\n              }\n            }\n          }\n        }\n\n        // send message\n        webMidiLink.postMessage(mergedTrack[pos++]['webMidiLink'], '*');\n      } while (pos < length && mergedTrack[pos]['time'] === time);\n\n      if (pos < length) {\n        procTime = Date.now() - procTime;\n        player.timer = player.window.setTimeout(\n          update,\n          player.tempo / (1000 * timeDivision) * (mergedTrack[pos]['time'] - time - procTime) * (1 / player.tempoRate)\n        );\n      } else {\n        // loop\n        player.ended();\n        player.pause = true;\n        if (player.enableCC111Loop && mark[0] && typeof mark[0]['pos'] === 'number') {\n          pos = mark[0]['pos'];\n        } else if (player.enableLoop) {\n          player.initSequence();\n          player.playSequence();\n        }\n      }\n\n      player.position = pos;\n      player.time = time;\n    };\n\n    if (!this.pause) {\n      this.timer = player.window.setTimeout(\n        update,\n        this.tempo / 1000 * timeDivision * this.track[0]['time']\n      );\n    } else {\n      // resume\n      this.timer = player.window.setTimeout(\n        update,\n        this.resume\n      );\n      this.pause = false;\n      this.resume = -1;\n    }\n  };\n\n  /**\n   * @param {ArrayBuffer} buffer\n   */\n  loadMidiFile(buffer) {\n    /** @type {SMF} */\n    const parser = new SMF(buffer);\n\n    this.init();\n    parser.parse();\n\n    this.mergeMidiTracks(parser);\n  };\n\n  /**\n   * @param {ArrayBuffer} buffer\n   */\n  loadMldFile(buffer) {\n    /** @type {Mld} */\n    const parser = new Mld(buffer);\n\n    this.init();\n    parser.parse();\n\n    // this.mergeMidiTracks(parser.convertToMidiTracks());\n    this.loadMidiFile(parser.convertToMidiTracks());\n  }\n\n  /**\n   * @param {Object} midi\n   */\n  mergeMidiTracks(midi) {\n    /** @type {Array.<Object>} */\n    const mergedTrack = this.track = [];\n    /** @type {Array.<Array.<Object>>} */\n    const tracks = midi.tracks;\n    /** @type {Array.<number>} */\n    const trackPosition = new Array(tracks.length);\n    /** @type {Array.<Array.<Array.<number>>>} */\n    const plainTracks = midi.plainTracks;\n    /** @type {Array.<string>} */\n    const copys = this.copyright = [];\n    /** @type {Array.<Object>} */\n    let track;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let jl;\n\n    // initialize\n    for (i = 0, il = tracks.length; i < il; ++i) {\n      trackPosition[i] = 0;\n    }\n\n    // merge\n    for (i = 0, il = tracks.length; i < il; ++i) {\n      track = tracks[i];\n      for (j = 0, jl = track.length; j < jl; ++j) {\n        if (midi.formatType === 0 && track[j].subtype === 'SequenceTrackName') {\n          this.sequenceName = track[j].data[0];\n        }\n\n        if (track[j].subtype === 'CopyrightNotice') {\n          copys.push(track[j].data[0]);\n        }\n\n        mergedTrack.push({\n          'track': i,\n          'eventId': j,\n          'time': track[j].time,\n          'event': track[j],\n          'webMidiLink': 'midi,' +\n            Array.prototype.map.call(\n              plainTracks[i][j],\n              (a) => {\n                return a.toString(16);\n              }\n            ).join(','),\n        });\n      }\n    }\n\n    // sort\n    mergedTrack.sort((a, b) => {\n      return a['time'] > b['time'] ? 1 : a['time'] < b['time'] ? -1 :\n        a['track'] > b['track'] ? 1 : a['track'] < b['track'] ? -1 :\n          a['eventId'] > b['eventId'] ? 1 : a['eventId'] < b['eventId'] ? -1 :\n            0;\n    });\n\n    // トータルの演奏時間\n    this.timeTotal = mergedTrack.slice(-1)[0].time;\n    this.sequence = midi;\n  };\n\n  /**\n   * @return {?string}\n   */\n  getSequenceName() {\n    return this.sequenceName;\n  };\n\n  /**\n   * @return {Array.<string>}\n   */\n  getCopyright() {\n    return this.copyright;\n  };\n\n  /**\n   * @return {number}\n   */\n  getPosition() {\n    return this.position;\n  }\n\n  /**\n   * @param {number} pos\n   */\n  setPosition(pos) {\n    this.position = pos;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return this.length;\n  }\n\n  /**\n   */\n  sendGmReset() {\n    if (this.webMidiLink) {\n      // F0 7E 7F 09 01 F7\n      this.webMidiLink.contentWindow.postMessage('midi,F0,7E,7F,09,01,F7', '*');\n    }\n  }\n\n  /**\n   */\n  sendAllSoundOff() {\n    if (this.webMidiLink) {\n      this.webMidiLink.contentWindow.postMessage('midi,b0,78,0', '*');\n    }\n  }\n\n  /**\n   * @param {number} time\n   * @return {string}\n   */\n  getTime(time) {\n    const secs = (this.tempo / 6000000) * time;\n\n    const hours = Math.floor(secs / (60 * 60));\n\n    const divisorForMinutes = secs % (60 * 60);\n    const minutes = Math.floor(divisorForMinutes / 60);\n\n    const divisorForSeconds = divisorForMinutes % 60;\n    const seconds = Math.ceil(divisorForSeconds);\n\n    return hours + ':' + ('00' + minutes).slice(-2) + ':' + ('00' + seconds).slice(-2);\n  }\n}\n","/**\n * Riff Parser class\n */\nexport default class Riff {\n  /**\n   * @param {ByteArray} input input buffer.\n   * @param {Object=} optParams option parameters.\n   */\n  constructor(input, optParams = {}) {\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {number} */\n    this.ip = optParams['index'] || 0;\n    /** @type {number} */\n    this.length = optParams['length'] || input.length - this.ip;\n    /** @type {Array.<RiffChunk>} */\n    this.chunkList;\n    /** @type {number} */\n    this.offset = this.ip;\n    /** @type {boolean} */\n    this.padding =\n      optParams['padding'] !== void 0 ? optParams['padding'] : true;\n    /** @type {boolean} */\n    this.bigEndian =\n      optParams['bigEndian'] !== void 0 ? optParams['bigEndian'] : false;\n  }\n\n  /**\n   */\n  parse() {\n    /** @type {number} */\n    const length = this.length + this.offset;\n\n    this.chunkList = [];\n\n    while (this.ip < length) {\n      this.parseChunk();\n    }\n  }\n\n  /**\n   */\n  parseChunk() {\n    /** @type {ByteArray} */\n    const input = this.input;\n    /** @type {number} */\n    let ip = this.ip;\n    /** @type {number} */\n    let size;\n\n    this.chunkList.push(new RiffChunk(\n      String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]),\n      (size = this.bigEndian ?\n        ((input[ip++] << 24) | (input[ip++] << 16) |\n          (input[ip++] << 8) | (input[ip++])) >>> 0 :\n        ((input[ip++]) | (input[ip++] << 8) |\n          (input[ip++] << 16) | (input[ip++] << 24)) >>> 0\n      ),\n      ip\n    ));\n\n    ip += size;\n\n    // padding\n    if (this.padding && ((ip - this.offset) & 1) === 1) {\n      ip++;\n    }\n\n    this.ip = ip;\n  }\n\n  /**\n   * @param {number} index chunk index.\n   * @return {?RiffChunk}\n   */\n  getChunk(index) {\n    /** @type {RiffChunk} */\n    const chunk = this.chunkList[index];\n\n    if (chunk === void 0) {\n      return null;\n    }\n\n    return chunk;\n  }\n\n  /**\n   * @return {number}\n   */\n  getNumberOfChunks() {\n    return this.chunkList.length;\n  }\n}\n\n/**\n * Riff Chunk Structure\n * @interface\n */\nclass RiffChunk {\n  /**\n   * @param {string} type\n   * @param {number} size\n   * @param {number} offset\n   */\n  constructor(type, size, offset) {\n    /** @type {string} */\n    this.type = type;\n    /** @type {number} */\n    this.size = size;\n    /** @type {number} */\n    this.offset = offset;\n  }\n}\n","import Riff from './riff';\nimport {\n  ChannelEvent,\n  SystemExclusiveEvent,\n  MetaEvent,\n} from './midi_event';\n\n/**\n * Standard Midi File Parser class\n */\nexport default class SMF {\n  /**\n   * @param {ByteArray} input input buffer.\n   * @param {Object=} optParams option parameters.\n   */\n  constructor(input, optParams = {}) {\n    optParams.padding = false;\n    optParams.bigEndian = true;\n\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {number} */\n    this.ip = optParams.index || 0;\n    /** @type {number} */\n    this.chunkIndex = 0;\n    /**\n     * @type {Riff}\n     * @private\n     */\n    this.riffParser_ = new Riff(input, optParams);\n\n    // MIDI File Information\n\n    /** @type {number} */\n    this.formatType = 0;\n    /** @type {number} */\n    this.numberOfTracks = 0;\n    /** @type {number} */\n    this.timeDivision = 0;\n    /** @type {Array.<Array.<Midi.Event>>} */\n    this.tracks = [];\n    /** @type {Array.<Array.<ByteArray>>} */\n    this.plainTracks = [];\n  };\n\n  /**\n   */\n  parse() {\n    /** @type {number} */\n    let i = 0;\n    /** @type {number} */\n    let il = 0;\n\n    // parse riff chunks\n    this.riffParser_.parse();\n\n    // parse header chunk\n    this.parseHeaderChunk();\n\n    // parse track chunks\n    for (i = 0, il = this.numberOfTracks; i < il; ++i) {\n      this.parseTrackChunk();\n    }\n  };\n\n  /**\n   */\n  parseHeaderChunk() {\n    /** @type {?{type: string, size: number, offset: number}} */\n    const chunk = this.riffParser_.getChunk(this.chunkIndex++);\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n\n    if (!chunk || chunk.type !== 'MThd') {\n      throw new Error('invalid header signature');\n    }\n\n    this.formatType = (data[ip++] << 8) | data[ip++];\n    this.numberOfTracks = (data[ip++] << 8) | data[ip++];\n    this.timeDivision = (data[ip++] << 8) | data[ip++];\n  };\n\n  /**\n   */\n  parseTrackChunk() {\n    /** @type {?{type: string, size: number, offset: number}} */\n    const chunk = this.riffParser_.getChunk(this.chunkIndex++);\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {number} */\n    let size = 0;\n    /** @type {number} */\n    let deltaTime = 0;\n    /** @type {number} */\n    let eventType = 0;\n    /** @type {number} */\n    let channel = 0;\n    /** @type {number} */\n    let prevEventType = -1;\n    /** @type {number} */\n    let prevChannel = -1;\n    /** @type {number} */\n    let tmp = 0;\n    /** @type {number} */\n    let totalTime = 0;\n    /** @type {number} */\n    let offset = 0;\n    /** @type {number} */\n    let length = 0;\n    /** @type {number} */\n    let status = 0;\n    /** @type {Event} */\n    let event;\n    /** @type {ByteArray} */\n    let plainBytes;\n\n    /** @return {number} */\n    const readNumber = () => {\n      /** @type {number} */\n      let result = 0;\n      /** @type {number} */\n      let tmp = 0;\n\n      do {\n        tmp = data[ip++];\n        result = (result << 7) | (tmp & 0x7f);\n      } while ((tmp & 0x80) !== 0);\n\n      return result;\n    };\n\n    if (!chunk || chunk.type !== 'MTrk') {\n      throw new Error('invalid header signature');\n    }\n\n    size = chunk.offset + chunk.size;\n    const eventQueue = [];\n    const plainQueue = [];\n\n    while (ip < size) {\n      // delta time\n      deltaTime = readNumber();\n      totalTime += deltaTime;\n\n      // offset\n      offset = ip;\n\n      // event type value, midi channel\n      status = data[ip++];\n      eventType = (status >> 4) & 0xf;\n      channel = status & 0xf;\n\n      // run status rule\n      if (eventType < 8) {\n        eventType = prevEventType;\n        channel = prevChannel;\n        status = (prevEventType << 4) | prevChannel;\n        ip--;\n        offset--;\n      } else {\n        prevEventType = eventType;\n        prevChannel = channel;\n      }\n\n      // TODO\n      const table = [, , , , , , , ,\n        'NoteOff',\n        'NoteOn',\n        'NoteAftertouch',\n        'ControlChange',\n        'ProgramChange',\n        'ChannelAftertouch',\n        'PitchBend',\n      ];\n\n      switch (eventType) {\n        // channel events\n        case 0x8:\n        /* FALLTHROUGH */\n        case 0x9:\n        /* FALLTHROUGH */\n        case 0xA:\n        /* FALLTHROUGH */\n        case 0xB:\n        /* FALLTHROUGH */\n        case 0xD:\n        /* FALLTHROUGH */\n        case 0xE:\n          event = new ChannelEvent(\n            table[eventType], deltaTime, totalTime,\n            channel, data[ip++], data[ip++]\n          );\n          break;\n        case 0xC:\n          event = new ChannelEvent(\n            table[eventType], deltaTime, totalTime,\n            channel, data[ip++]\n          );\n          break;\n        // meta events, system exclusive event\n        case 0xF:\n          switch (channel) {\n            // SysEx event\n            case 0x0:\n              tmp = readNumber();\n              if (data[ip + tmp - 1] !== 0xf7) {\n                throw new Error('invalid SysEx event');\n              }\n              event = new SystemExclusiveEvent(\n                'SystemExclusive', deltaTime, totalTime,\n                data.subarray(ip, (ip += tmp) - 1)\n              );\n              break;\n            case 0x7:\n              tmp = readNumber();\n              event = new SystemExclusiveEvent(\n                'SystemExclusive(F7)', deltaTime, totalTime,\n                data.subarray(ip, (ip += tmp))\n              );\n              break;\n            // meta event\n            case 0xF:\n              eventType = data[ip++];\n              tmp = readNumber();\n              switch (eventType) {\n                case 0x00: // sequence number\n                  event = new MetaEvent(\n                    'SequenceNumber', deltaTime, totalTime, [data[ip++], data[ip++]]\n                  );\n                  break;\n                case 0x01: // text event\n                  event = new MetaEvent(\n                    'TextEvent', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x02: // copyright notice\n                  event = new MetaEvent(\n                    'CopyrightNotice', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x03: // sequence/track name\n                  event = new MetaEvent(\n                    'SequenceTrackName', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x04: // instrument name\n                  event = new MetaEvent(\n                    'InstrumentName', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x05: // lyrics\n                  event = new MetaEvent(\n                    'Lyrics', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x06: // marker\n                  event = new MetaEvent(\n                    'Marker', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x07: // cue point\n                  event = new MetaEvent(\n                    'CuePoint', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x20: // midi channel prefix\n                  event = new MetaEvent(\n                    'MidiChannelPrefix', deltaTime, totalTime, [data[ip++]]\n                  );\n                  break;\n                case 0x2f: // end of track\n                  event = new MetaEvent(\n                    'EndOfTrack', deltaTime, totalTime, []\n                  );\n                  break;\n                case 0x51: // set tempo\n                  event = new MetaEvent(\n                    'SetTempo', deltaTime, totalTime, [(data[ip++] << 16) | (data[ip++] << 8) | data[ip++]]\n                  );\n                  break;\n                case 0x54: // smpte offset\n                  event = new MetaEvent(\n                    'SmpteOffset', deltaTime, totalTime, [data[ip++], data[ip++], data[ip++], data[ip++], data[ip++]]\n                  );\n                  break;\n                case 0x58: // time signature\n                  event = new MetaEvent(\n                    'TimeSignature', deltaTime, totalTime, [data[ip++], data[ip++], data[ip++], data[ip++]]\n                  );\n                  break;\n                case 0x59: // key signature\n                  event = new MetaEvent(\n                    'KeySignature', deltaTime, totalTime, [data[ip++], data[ip++]]\n                  );\n                  break;\n                case 0x7f: // sequencer specific\n                  event = new MetaEvent(\n                    'SequencerSpecific', deltaTime, totalTime, [data.subarray(ip, ip += tmp)]\n                  );\n                  break;\n                default: // unknown\n                  event = new MetaEvent(\n                    'Unknown', deltaTime, totalTime, [eventType, data.subarray(ip, ip += tmp)]\n                  );\n              }\n              break;\n            default:\n              console.log('unknown message:', status.toString(16));\n          }\n          break;\n        // error\n        default:\n          throw new Error('invalid status');\n      }\n\n      // plain queue\n      length = ip - offset;\n      plainBytes = data.subarray(offset, offset + length);\n      plainBytes[0] = status;\n      if (\n        event instanceof ChannelEvent &&\n        event.subtype === 'NoteOn' &&\n        /** @type {ChannelEvent} */\n        (event).parameter2 === 0\n      ) {\n        event.subtype = table[8];\n        plainBytes = new Uint8Array([0x80 | event.channel, event.parameter1, event.parameter2]);\n      }\n      plainQueue.push(plainBytes);\n\n      // event queue\n      eventQueue.push(event);\n    }\n\n    this.tracks.push(eventQueue);\n    this.plainTracks.push(plainQueue);\n  };\n};\n"],"sourceRoot":""}