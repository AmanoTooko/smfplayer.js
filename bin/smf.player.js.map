{"version":3,"sources":["webpack://SMF/webpack/universalModuleDefinition","webpack://SMF/webpack/bootstrap","webpack://SMF/./node_modules/ini/ini.js","webpack://SMF/./src/3mle.js","webpack://SMF/./src/PSGConverter.js","webpack://SMF/./src/midi_event.js","webpack://SMF/./src/mld.js","webpack://SMF/./src/mmi.js","webpack://SMF/./src/mms.js","webpack://SMF/./src/ms2mml.js","webpack://SMF/./src/player.js","webpack://SMF/./src/riff.js","webpack://SMF/./src/smf.js"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH,MAAM,GAAG,IAAI,QAAQ,KAAK,MAAM,GAAG,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,wBAAwB;AACjC,GAAG;AACH,mDAAmD;AACnD;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA,gBAAgB;AAChB;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO,YAAY;AACnB;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjMA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACmC;AACxC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACe,uCAAuC,4CAAgB;AACtE;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,OAAO;AACvB;;AAEA;AACA,eAAe,MAAM;AACrB;AACA;AACA,yBAAyB,gEAAoB;AAC7C,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;;AAEA,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,MAAM;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,qDAAS;AAChC;AACA,uBAAuB,wDAAY;AACnC;AACA,uBAAuB,wDAAY;;AAEnC,oBAAoB,aAAa;AACjC,6BAA6B,qDAAY,EAAE,qFAAqF;AAChI;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,qDAAS;AAClC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClJA;AAAA;AAAA;AAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,aAAa,MAAM;AACnB;AACA,4BAA4B;AAC5B,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,KAAK;AACpB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,MAAM;AACrB;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,wDAAY;AACxC,WAAW;AACX;AACA,4BAA4B,wDAAY;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,WAAW;AACX;AACA;AACA,4BAA4B,wDAAY;AACxC;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClNA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,mBAAmB;AAClC;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;;AAME;;;;;;;;;;;;;ACnFF;AAAA;AAAA;AACA;AACA;AACe;AACf;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,uBAAuB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,eAAe;AAChC;AACA,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,+BAA+B;AAC9C;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,0BAA0B;AACvC,cAAc;AACd;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,eAAe;AAChC;;AAEA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC/3BA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACL;AACwC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACe,uBAAuB,4CAAgB;AACtD;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC;AACA,eAAe,MAAM;AACrB;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,2BAA2B;AAC1C;AACA,gBAAgB,OAAO;AACvB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;;AAEA,eAAe,MAAM;AACrB;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,MAAM;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,MAAM;AACtB;AACA,eAAe,MAAM;AACrB;AACA;AACA,yBAAyB,gEAAoB;AAC7C;AACA,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB;;AAEA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;;AAEA,kBAAkB,MAAM;AACxB;;AAEA;AACA,qBAAqB,qDAAS;AAC9B;AACA,qBAAqB,wDAAY;AACjC;AACA;AACA,uBAAuB,wDAAY;AACnC;AACA;AACA,qBAAqB,wDAAY;;AAEjC;AACA,yBAAyB,4BAA4B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,aAAa;AACjC,6BAA6B,qDAAY,EAAE,kFAAkF;AAC7H;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAS;AAChC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACpB;AACuD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC,eAAe,OAAO;AACtB;AACA,eAAe,IAAI;AACnB,iBAAiB,0CAAG;AACpB,eAAe,uBAAuB;AACtC;AACA,eAAe,2BAA2B;AAC1C;AACA,gBAAgB,OAAO;AACvB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA,eAAe,OAAO;AACtB,yCAAyC;AACzC,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB,8BAA8B;AAC9B,gBAAgB,OAAO;AACvB;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,MAAM;AACrB;AACA;AACA,yBAAyB,gEAAoB;AAC7C,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA,oBAAoB,OAAO;AAC3B;;AAEA;AACA,uBAAuB,qDAAS;AAChC;AACA,uBAAuB,wDAAY;AACnC;AACA,uBAAuB,wDAAY;;AAEnC;AACA,2BAA2B,qBAAqB;AAChD,sBAAsB,aAAa;AACnC,+BAA+B,qDAAY,EAAE,kFAAkF;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAS;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C,iBAAiB,MAAM;AACvB;;AAEA,iBAAiB,MAAM;AACvB;;AAEA,iBAAiB,MAAM;AACvB;;AAEA,qBAAqB,mBAAmB;AACxC,mBAAmB,MAAM;AACzB;AACA,kBAAkB,WAAW;AAC7B;;AAEA,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2BAA2B,qDAAS;AAC7C;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2BAA2B,gEAAoB;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnMA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACL;AACI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACe,6BAA6B,4CAAgB;AAC5D;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC;AACA,eAAe,YAAY;AAC3B;AACA,eAAe,UAAU;AACzB;AACA,eAAe,SAAS;AACxB;AACA,gBAAgB,QAAQ;AACxB;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,2BAA2B;AAC1C;AACA,gBAAgB,OAAO;AACvB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB;;AAEA,mBAAmB,uBAAuB;AAC1C,kBAAkB,aAAa;AAC/B,2BAA2B,qDAAY,EAAE,qFAAqF;AAC9H;AACA;AACA;;AAEA;AACA,qBAAqB,qDAAS;AAC9B;AACA;AACA;;;;;;;;;;;;;AClEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwB;AACA;AACc;AACD;AACS;AACjB;AAC7B;AACA;AACA;AACO;AACP;AACA,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB,wBAAwB;AACxB,eAAe,kBAAkB;AACjC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,yBAAyB;AACxC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,cAAc;AAC3B;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,SAAS,YAAY,EAAE;AACtC;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,gBAAgB;AACjC;AACA,iBAAiB,EAAE;AACnB;AACA,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA,eAAe,IAAI;AACnB,uBAAuB,4CAAG;;AAE1B;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA,eAAe,IAAI;AACnB,uBAAuB,4CAAG;;AAE1B;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA,eAAe,eAAe;AAC9B,uBAAuB,+CAAc;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA,eAAe,iBAAiB;AAChC,uBAAuB,4CAAgB;;AAEvC;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA,eAAe,yBAAyB;AACxC,uBAAuB,6CAAwB;;AAE/C;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA,eAAe,SAAS;AACxB,uBAAuB,4CAAQ;;AAE/B;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,+BAA+B;AAC9C;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA,mCAAmC,QAAQ;AAC3C;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC/rBA;AAAA;AAAA;AACA;AACA;AACe;AACf;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,kBAAkB;AACjC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,eAAe,UAAU;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;;;;;;;;;;;;;AChHA;AAAA;AAAA;AAAA;AAA0B;AAKJ;;AAEtB;AACA;AACA;AACe;AACf;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC;AACA;;AAEA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA,cAAc;AACd;AACA;AACA,2BAA2B,6CAAI;;AAE/B;;AAEA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,2BAA2B;AAC1C;AACA,eAAe,0BAA0B;AACzC;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,EAAE,4CAA4C;AAC7D;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,EAAE,4CAA4C;AAC7D;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,MAAM;AACrB;AACA,eAAe,UAAU;AACzB;;AAEA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAY;AAClC;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAY;AACrC;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"smf.player.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SMF\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SMF\"] = factory();\n\telse\n\t\troot[\"SMF\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/player.js\");\n","exports.parse = exports.decode = decode\n\nexports.stringify = exports.encode = encode\n\nexports.safe = safe\nexports.unsafe = unsafe\n\nvar eol = typeof process !== 'undefined' &&\n  process.platform === 'win32' ? '\\r\\n' : '\\n'\n\nfunction encode (obj, opt) {\n  var children = []\n  var out = ''\n\n  if (typeof opt === 'string') {\n    opt = {\n      section: opt,\n      whitespace: false\n    }\n  } else {\n    opt = opt || {}\n    opt.whitespace = opt.whitespace === true\n  }\n\n  var separator = opt.whitespace ? ' = ' : '='\n\n  Object.keys(obj).forEach(function (k, _, __) {\n    var val = obj[k]\n    if (val && Array.isArray(val)) {\n      val.forEach(function (item) {\n        out += safe(k + '[]') + separator + safe(item) + '\\n'\n      })\n    } else if (val && typeof val === 'object') {\n      children.push(k)\n    } else {\n      out += safe(k) + separator + safe(val) + eol\n    }\n  })\n\n  if (opt.section && out.length) {\n    out = '[' + safe(opt.section) + ']' + eol + out\n  }\n\n  children.forEach(function (k, _, __) {\n    var nk = dotSplit(k).join('\\\\.')\n    var section = (opt.section ? opt.section + '.' : '') + nk\n    var child = encode(obj[k], {\n      section: section,\n      whitespace: opt.whitespace\n    })\n    if (out.length && child.length) {\n      out += eol\n    }\n    out += child\n  })\n\n  return out\n}\n\nfunction dotSplit (str) {\n  return str.replace(/\\1/g, '\\u0002LITERAL\\\\1LITERAL\\u0002')\n    .replace(/\\\\\\./g, '\\u0001')\n    .split(/\\./).map(function (part) {\n      return part.replace(/\\1/g, '\\\\.')\n      .replace(/\\2LITERAL\\\\1LITERAL\\2/g, '\\u0001')\n    })\n}\n\nfunction decode (str) {\n  var out = {}\n  var p = out\n  var section = null\n  //          section     |key      = value\n  var re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i\n  var lines = str.split(/[\\r\\n]+/g)\n\n  lines.forEach(function (line, _, __) {\n    if (!line || line.match(/^\\s*[;#]/)) return\n    var match = line.match(re)\n    if (!match) return\n    if (match[1] !== undefined) {\n      section = unsafe(match[1])\n      p = out[section] = out[section] || {}\n      return\n    }\n    var key = unsafe(match[2])\n    var value = match[3] ? unsafe(match[4]) : true\n    switch (value) {\n      case 'true':\n      case 'false':\n      case 'null': value = JSON.parse(value)\n    }\n\n    // Convert keys with '[]' suffix to an array\n    if (key.length > 2 && key.slice(-2) === '[]') {\n      key = key.substring(0, key.length - 2)\n      if (!p[key]) {\n        p[key] = []\n      } else if (!Array.isArray(p[key])) {\n        p[key] = [p[key]]\n      }\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key])) {\n      p[key].push(value)\n    } else {\n      p[key] = value\n    }\n  })\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  Object.keys(out).filter(function (k, _, __) {\n    if (!out[k] ||\n      typeof out[k] !== 'object' ||\n      Array.isArray(out[k])) {\n      return false\n    }\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    var parts = dotSplit(k)\n    var p = out\n    var l = parts.pop()\n    var nl = l.replace(/\\\\\\./g, '.')\n    parts.forEach(function (part, _, __) {\n      if (!p[part] || typeof p[part] !== 'object') p[part] = {}\n      p = p[part]\n    })\n    if (p === out && nl === l) {\n      return false\n    }\n    p[nl] = out[k]\n    return true\n  }).forEach(function (del, _, __) {\n    delete out[del]\n  })\n\n  return out\n}\n\nfunction isQuoted (val) {\n  return (val.charAt(0) === '\"' && val.slice(-1) === '\"') ||\n    (val.charAt(0) === \"'\" && val.slice(-1) === \"'\")\n}\n\nfunction safe (val) {\n  return (typeof val !== 'string' ||\n    val.match(/[=\\r\\n]/) ||\n    val.match(/^\\[/) ||\n    (val.length > 1 &&\n     isQuoted(val)) ||\n    val !== val.trim())\n      ? JSON.stringify(val)\n      : val.replace(/;/g, '\\\\;').replace(/#/g, '\\\\#')\n}\n\nfunction unsafe (val, doUnesc) {\n  val = (val || '').trim()\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\") {\n      val = val.substr(1, val.length - 2)\n    }\n    try { val = JSON.parse(val) } catch (_) {}\n  } else {\n    // walk the val to find the first not-escaped ; character\n    var esc = false\n    var unesc = ''\n    for (var i = 0, l = val.length; i < l; i++) {\n      var c = val.charAt(i)\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1) {\n          unesc += c\n        } else {\n          unesc += '\\\\' + c\n        }\n        esc = false\n      } else if (';#'.indexOf(c) !== -1) {\n        break\n      } else if (c === '\\\\') {\n        esc = true\n      } else {\n        unesc += c\n      }\n    }\n    if (esc) {\n      unesc += '\\\\'\n    }\n    return unesc.trim()\n  }\n  return val\n}\n","import PSGConverter from './PSGConverter';\nimport { MetaEvent, ChannelEvent, SystemExclusiveEvent } from './midi_event';\nimport MakiMabiSequence from './mms';\n/**\n * @classdesc   3 Macro Language Editor (3MLE) mml file Parser\n *\n * @author      Logue <logue@hotmail.co.jp>\n * @copyright   2019 Logue <https://logue.dev/> All rights reserved.\n * @license     MIT\n */\nexport default class ThreeMacroLanguageEditor extends MakiMabiSequence {\n  /**\n   * @param {ByteArray} input\n   * @param {Object=} optParams\n   */\n  constructor(input, optParams = {}) {\n    super(input, optParams);\n  }\n  /**\n   */\n  parse() {\n    this.parseHeader();\n    this.parseTracks();\n    this.toPlainTrack();\n  };\n  /**\n   */\n  parseHeader() {\n    const header = this.input.Settings;\n    /** @type {TextEncoder} */\n    this.encoder = new TextEncoder(header.Encoding || 'shift_jis');\n    /** @param {string} */\n    this.title = header.Title;\n    /** @param {string} */\n    this.author = header.Source;\n    /** @param {number} */\n    this.timeDivision = header.TimeBase | 0 || 32;\n\n    // 曲名と著者情報を付加\n    /** @type {array}  */\n    const headerTrack = [];\n    // GM Reset\n    headerTrack.push(new SystemExclusiveEvent('SystemExclusive', 0, 0, [0x7e, 0x7f, 0x09, 0x01]));\n    headerTrack.push(new MetaEvent('SequenceTrackName', 0, 0, [this.title]));\n    headerTrack.push(new MetaEvent('CopyrightNotice', 0, 0, [this.author]));\n    headerTrack.push(new MetaEvent('TextEvent', 0, 0, [header.Memo]));\n    headerTrack.push(new MetaEvent('TimeSignature', 0, 0, [header.TimeSignatureNN | 0 || 4, header.TimeSignatureDD | 0 || 4, 0, 0]));\n    headerTrack.push(new MetaEvent('EndOfTrack', 0, 0));\n    this.tracks.push(headerTrack);\n\n    // 3MLE EXTENSION、Settingsを取り除く\n    delete this.input['3MLE EXTENSION'];\n    delete this.input['Settings'];\n  };\n\n  /**\n   * MML parse\n   */\n  parseTracks() {\n    const input = this.input;\n    /** @type {array} 終了時間比較用 */\n    const endTimes = [];\n\n    /** @type {array} 各ブロックのMML */\n    const mmls = [];\n    /** @type {array} 各ブロックの演奏情報 */\n    const settings = [];\n\n    for (const block in input) {\n      if (input.hasOwnProperty(block)) {\n        if (block.match(/^Channel(\\d+)$/i)) {\n          // MMLは[Channel[n]]ブロックのキー\n\n          // ひどいファイル形式だ・・・。\n          mmls[(RegExp.$1 | 0) - 1] = Object.keys(input[block]).join('').replace(/\\/\\*([^*]|\\*[^\\/])*\\*\\//g, '');\n        }\n\n        if (block.match(/^ChannelProperty(\\d+)$/i)) {\n          // 各パートの楽器情報などは[ChannelProperty[n]]に格納されている\n          settings[(RegExp.$1 | 0) - 1] = {\n            name: input[block].Name,\n            instrument: input[block].Patch | 0,\n            panpot: input[block].Pan | 0,\n          };\n        }\n      }\n    }\n\n    /** @type {array} 整形済みデータ */\n    const data = [];\n\n    // データを整形\n    for (const no in mmls) {\n      if (mmls.hasOwnProperty(no)) {\n        if (settings[no] !== void 0) {\n          data[no] = {\n            mml: mmls[no],\n            name: settings[no].name || '',\n            instrument: settings[no].instrument || 0,\n            panpot: settings[no].panpot || 64,\n          };\n        } else {\n          data[no] = {\n            mml: mmls[no],\n            name: '',\n            instrument: 0,\n            panpot: 64,\n          };\n        }\n      }\n    }\n\n    // console.log(data);\n\n    for (const part in data) {\n      if (data.hasOwnProperty(part)) {\n        /** @type {number} */\n        const ch = part | 0;\n        /** @type {array} MIDIイベント */\n        let track = [];\n        if (data[part].mml === '') {\n          // 空っぽのMMLトラックの場合処理しない\n          continue;\n        }\n\n        // 楽器名\n        track.push(new MetaEvent('InsturumentName', 0, 48, [data[part].name]));\n        // プログラムチェンジ\n        track.push(new ChannelEvent('ProgramChange', 0, 96, ch, data[part].instrument));\n        // パン\n        track.push(new ChannelEvent('ControlChange', 0, 154, ch, 10, data[part].panpot));\n\n        /** @param {PSGConverter} */\n        const mml2Midi = new PSGConverter({ timeDivision: this.timeDivision, channel: ch, timeOffset: 386, mml: data[part].mml });\n        // トラックにマージ\n        track = track.concat(mml2Midi.events);\n        // 演奏時間を更新\n        endTimes.push(mml2Midi.endTime);\n\n        // トラック終了\n        track.concat(new MetaEvent('EndOfTrack', 0, Math.max(endTimes)));\n        this.tracks.push(track);\n      }\n    }\n    this.numberOfTracks = this.tracks.length;\n  }\n}\n","import { ChannelEvent, MetaEvent } from './midi_event';\n/**\n * @class       PSGConverter\n * @classdesc   Mabinogi MML and Maple Story 2 MML to MIDI Converter.\n * @version     3.0\n *\n * @author      Logue <logue@hotmail.co.jp>\n * @copyright   2007-2013,2018-2019 Logue <http://logue.dev/> All rights reserved.\n * @license     MIT\n */\nexport default class PSGConverter {\n  /**\n   * Constructor\n   * @param {array} optParams\n   */\n  constructor(optParams = {}) {\n    /** @type {number} 解像度 */\n    this.timeDivision = optParams.timeDivision | 0 || 96;\n    /** @type {number} チャンネル */\n    this.channel = optParams.channel | 0;\n    /** @type {number} 演奏開始までのオフセット時間 */\n    this.timeOffset = optParams.timeOffset | 0;\n    /** @type {bool} GM互換モードにするか */\n    this.isGMMode = optParams.timeOffset | false;\n    /** @type {string} MMLのチャンネルごとのマッチパターン */\n    this.PATTERN = /[A-GLNORTV<>][\\+\\#-]?[0-9]*\\.?&?/ig;\n    /** @type {Array<string, number>} ノートのマッチングテーブル */\n    this.NOTE_TABLE = {\n      'c': 0,\n      'd': 2,\n      'e': 4,\n      'f': 5,\n      'g': 7,\n      'a': 9,\n      'b': 11,\n    };\n    /** @type {number} １拍（Tick連動） */\n    this.MINIM = this.timeDivision * 2;\n    /** @type {number} 1小節 */\n    this.SEMIBREVE = this.timeDivision * 4;\n    /** @type {array} MML */\n    this.mml = optParams.mml;\n    /** @type {array} イベント */\n    this.events = [];\n    /** @type {array} WML送信用イベント */\n    this.plainEvents = [];\n    /** @type {number} 終了時間 */\n    this.endTime = 0;\n    // 変換実行\n    this.parse();\n  }\n  /**\n   * Parse MML\n   */\n  parse() {\n    /** @type {Array} MMLストリーム */\n    let notes;\n    try {\n      notes = this.mml.match(this.PATTERN);\n    } catch (e) {\n      console.warn('Could not parse MML.', this.mml);\n      return;\n    }\n    /** @type {number} タイムスタンプ */\n    let time = this.timeOffset;\n    /** @type {number} 現在の音の長さ */\n    let cLength = this.timeDivision;\n    /** @type {number} 現在の音階 */\n    let cNote = 0;\n    /** @type {boolean} タイ記号 */\n    let tieEnabled = false;\n    /** @type {number} 現在のボリューム(0～15)*/\n    let cVolume = 8;\n    /** @type {number} 現在のオクターブ(1~8)*/\n    let cOctave = 4;\n    /** @type {Array} イベント */\n    const events = [];\n\n    for (const mnid in notes) {\n      if (notes.hasOwnProperty(mnid)) {\n        /** @type {number} 現在の音符の長さ */\n        let tick = cLength | 0;\n        /** @type {number} 値*/\n        let val = 0;\n\n        // 音長(L)、オクターブ(O<>)、テンポ（T）、ボリューム（V）をパース\n        if (notes[mnid].match(/([LOTV<>])([1-9][0-9]*|0?)(\\.?)(&?)/i)) {\n          val = parseInt(RegExp.$2);\n          if (tieEnabled && RegExp.$4 !== '&') {\n            // タイ記号\n            tieEnabled = false;\n            events.push(new ChannelEvent('NoteOff', 0, time, this.channel, cNote));\n          }\n          switch (RegExp.$1) {\n            case 'L':\n            case 'l':\n              // 音長設定 Ln[.] (n=1～192)\n              if (val >= 1 && val <= this.MINIM) {\n                cLength = Math.floor(this.SEMIBREVE / val);\n                if (RegExp.$3 == '.') {\n                  // 付点の場合音長を1.5倍する\n                  cLength = Math.floor(cLength * 1.5);\n                }\n              }\n              break;\n            case 'O':\n            case 'o':\n              // オクターブ設定 On (n=1～8)\n              if (val >= 0 && val <= 8) {\n                cOctave = val;\n              }\n              break;\n            case 'T':\n            case 't':\n              // テンポ設定 Tn (n=32～255)\n              events.push(new MetaEvent('SetTempo', 0, time, [Math.floor(60000000 / val)]));\n              break;\n            case 'V':\n            case 'v':\n              // ボリューム調整\n              if (val >= 0 && val <= 15) {\n                cVolume = val;\n              }\n              break;\n\n            // 簡易オクターブ設定 {<>}\n            case '<':\n              cOctave = (cOctave <= 0) ? 0 : (cOctave - 1);\n              break;\n            case '>':\n              cOctave = (cOctave >= 8) ? 8 : (cOctave + 1);\n              break;\n          }\n        } else if (notes[mnid].match(/([A-GN])([\\+\\#-]?)([0-9]*)(\\.?)(&?)/i)) {\n          // ノート命令（CDEFGAB）、絶対音階指定（N）をパース\n          /** @type {number} 音階 */\n          let note = 0;\n          val = RegExp.$3 | 0;\n\n          if (RegExp.$1 === 'n' || RegExp.$1 === 'N') {\n            // Nn：絶対音階指定 Lで指定した長さに設定\n            note = val;\n          } else {\n            // [A-G]：音名表記\n            // 音符の長さ指定: n分音符→128分音符×tick数\n            if (1 <= val && val <= this.MINIM) {\n              tick = Math.floor(this.SEMIBREVE / val); // L1 -> 384tick .. L64 -> 6tick\n            }\n            if (RegExp.$4 === '.') {\n              tick = Math.floor(tick * 1.5); // 付点つき -> 1.5倍\n            }\n\n            // 音名→音階番号変換(C1 -> 12, C4 -> 48, ..)\n            note = 12 * cOctave + this.NOTE_TABLE[RegExp.$1.toLowerCase()];\n\n            // 調音記号の処理\n            if (RegExp.$2 === '+' || RegExp.$2 === '#') {\n              note++;\n            } else if (RegExp.$2 === '-') {\n              note--;\n            }\n          }\n          // 1オクターブ低く演奏される不具合を修正 060426\n          note += 12;\n\n          if (!tieEnabled) {\n            // 前回タイ記号が無いときのみノートオン\n            events.push(new ChannelEvent('NoteOn', 0, time, this.channel, note, 8 * cVolume));\n          } else if (note !== cNote) {\n            // c&dなど無効なタイの処理\n            events.push(new ChannelEvent('NoteOff', 0, time, this.channel, cNote));\n            tieEnabled = false;\n          }\n\n          // タイムカウンタを音符の長さだけ進める\n          time += tick;\n\n          // ノートオフ命令の追加\n          if (RegExp.$5 === '&') {\n            // タイ記号の処理\n            tieEnabled = true;\n            cNote = note; // 直前の音階を保存\n          } else {\n            tieEnabled = false;\n            // 発音と消音が同じ時間の場合、そこのノートが再生されないため、消音時にtimeを-1する。\n            events.push(new ChannelEvent('NoteOff', 0, time, this.channel, note));\n          }\n        } else if (notes[mnid].match(/[rR]([0-9]*)(\\.?)/)) {\n          // 休符設定 R[n][.] (n=1～64)\n          val = RegExp.$1 | 0;\n\n          if (1 <= val && val <= this.MINIM) {\n            // L1 -> 128tick .. L64 -> 2tick\n            tick = Math.floor(this.SEMIBREVE / val);\n          }\n\n          if (RegExp.$2 === '.') {\n            // 付点つき -> 1.5倍\n            tick = Math.floor(tick * 1.5);\n          }\n\n          time += tick; // タイムカウンタを休符の長さだけ進める\n        } else {\n          console.warn('unknown signeture.', notes[mnid]);\n        }\n      }\n    }\n    this.events = events;\n    this.endTime = time;\n  }\n}\n","/**\n * Midi Event abstract Structure\n */\nclass Event {\n  /**\n   * @param {string} subtype event subtype name.\n   * @param {number} deltaTime delta time.\n   * @param {number} time time.\n   */\n  constructor(subtype, deltaTime, time) {\n    /** @type {string} */\n    this.subtype = subtype;\n    /** @type {number} */\n    this.deltaTime = deltaTime;\n    /** @type {number} */\n    this.time = time;\n  }\n}\n\n/**\n * Midi Channel Event Structure\n * @extends {Event}\n */\nclass ChannelEvent extends Event {\n  /**\n   * @param {string} subtype\n   * @param {number} deltaTime delta time.\n   * @param {number} time time.\n   * @param {number} channel\n   * @param {number=} optParameter1\n   * @param {number=} optParameter2\n   */\n  constructor(subtype, deltaTime, time, channel, optParameter1, optParameter2) {\n    super(subtype, deltaTime, time);\n    /** @type {number} */\n    this.channel = channel;\n    /** @type {(number|undefined)} */\n    this.parameter1 = optParameter1;\n    /** @type {(number|undefined)} */\n    this.parameter2 = optParameter2;\n  }\n}\n\n/**\n * System Exclusive Event Structure\n * @extends {Event}\n */\nclass SystemExclusiveEvent extends Event {\n  /**\n   * @param {string} subtype\n   * @param {number} deltaTime delta time.\n   * @param {number} time time.\n   * @param {ByteArray} data\n   */\n  constructor(subtype, deltaTime, time, data) {\n    super(subtype, deltaTime, time);\n    /** @type {ByteArray} */\n    this.data = data;\n  }\n}\n\n/**\n * Midi Meta Event Structure\n * @extends {Event}\n */\nclass MetaEvent extends Event {\n  /**\n   * @param {string} subtype\n   * @param {number} deltaTime delta time.\n   * @param {number} time time.\n   * @param {Array.<*>} data meta data.\n   */\n  constructor(subtype, deltaTime, time, data) {\n    super(subtype, deltaTime, time);\n    /** @type {Array.<*>} */\n    this.data = data;\n  };\n}\n\nexport {\n  ChannelEvent,\n  SystemExclusiveEvent,\n  MetaEvent,\n};\n","/**\n * Mld Parser Class\n */\nexport default class Mld {\n  /**\n   * @param {ByteArray} input\n   * @param {Object=} optParams\n   */\n  constructor(input, optParams = {}) {\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {number} */\n    this.ip = optParams.index || 0;\n    /** @type {number} */\n    this.timeDivision = optParams.timeDivision || 48;\n    /** @type {Object} */\n    this.header;\n    /** @type {Object} */\n    this.dataInformation;\n    /** @type {Array.<Array.<Object>>} */\n    this.tracks;\n  };\n\n  /**\n   */\n  parse() {\n    this.parseHeader();\n    this.parseDataInformation();\n    this.parseTracks();\n  };\n\n  /**\n   */\n  parseHeader() {\n    /** @type {ByteArray} */\n    const input = this.input;\n    /** @type {number} */\n    let ip = this.ip;\n    /** @type {Object} */\n    const header = this.header = {};\n    /** @type {string} */\n    const signature =\n      String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]);\n\n    if (signature !== 'melo') {\n      throw new Error('invalid MFi signature:' + signature);\n    }\n\n    header.fileLength = (\n      (input[ip++] << 24) | (input[ip++] << 16) |\n      (input[ip++] << 8) | input[ip++]\n    ) >>> 0;\n\n    header.trackOffset = (\n      (input[ip++] << 16) | input[ip++]\n    ) + ip;\n\n    header.dataMajorType = input[ip++];\n    header.dataMinorType = input[ip++];\n    header.numberOfTracks = input[ip++];\n\n    this.ip = ip;\n  };\n\n  /**\n   */\n  parseDataInformation() {\n    /** @type {ByteArray} */\n    const input = this.input;\n    /** @type {number} */\n    let ip = this.ip;\n    /** @type {Object} */\n    const dataInformation = this.dataInformation = {\n      'copy': null,\n      'date': null,\n      'exst': null,\n      'note': null,\n      'prot': null,\n      'sorc': null,\n      'titl': null,\n      'trac': null,\n      'vers': null,\n    };\n    /** @type {string} */\n    let type;\n    /** @type {number} */\n    let size;\n\n    while (ip < this.header.trackOffset) {\n      type =\n        String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]);\n      size = (input[ip++] << 8) | input[ip++];\n\n      switch (type) {\n        case 'titl':\n        /* FALLTHROUGH */\n        case 'copy':\n        /* FALLTHROUGH */\n        case 'vers':\n        /* FALLTHROUGH */\n        case 'date':\n        /* FALLTHROUGH */\n        case 'prot':\n          dataInformation[type] = String.fromCharCode.apply(\n            null,\n            input.subarray(ip, ip += size)\n          );\n          break;\n        case 'sorc':\n          dataInformation[type] = input[ip++];\n          break;\n        case 'note':\n          dataInformation[type] = (input[ip++] << 8) | input[ip++];\n          break;\n        case 'exst':\n          /* FALLTHROUGH */\n          break;\n        default:\n          dataInformation[type] = input.subarray(ip, ip += size);\n          break;\n      }\n    }\n\n    this.ip = ip;\n  }\n\n  /**\n   */\n  parseTracks() {\n    /** @type {ByteArray} */\n    const input = this.input;\n    /** @type {number} */\n    let ip = this.ip;\n    /** @type {string} */\n    let signature;\n    /** @type {number} */\n    let size;\n    /** @type {number} */\n    let limit;\n    /** @type {number} */\n    let status;\n    /** @type {number} */\n    let extendStatus;\n    /** @type {Object} */\n    let message;\n    /** @type {Array.<Array.<Object>>} */\n    const tracks = this.tracks = [];\n    /** @type {Array.<Object>} */\n    let track;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /**\n     * @return {Array.<Object>}\n     */\n    const parseEditInstrument = () => {\n      /** @type {number} */\n      const length = (input[ip++] << 8) | input[ip++];\n      /** @type {number} */\n      const limit = ip + length;\n      /** @type {Array.<Object>} */\n      const result = [];\n      /** @type {Object} */\n      let info;\n\n      // const\n      if (input[ip++] !== 1) {\n        throw new Error('invalid EditInstrument const value:' + input[ip - 1]);\n      }\n\n      while (ip < limit) {\n        info = {};\n\n        info['part'] = (input[ip++] >> 4) & 0x3;\n        info['modulator'] = {\n          'ML': input[ip] >> 5,\n          'VIV': (input[ip] >> 4) & 0x1,\n          'EG': (input[ip] >> 3) & 0x1,\n          'SUS': (input[ip] >> 2) & 0x1,\n          'RR': ((input[ip++] & 0x3) << 2) | (input[ip] >> 6),\n          'DR': (input[ip] >> 4) & 0xf,\n          'AR': ((input[ip++] & 0x3) << 2) | (input[ip] >> 6),\n          'SL': (input[ip] >> 4) & 0xf,\n          'TL': ((input[ip++] & 0x3) << 4) | (input[ip] >> 4),\n          'WF': (input[ip] >> 3) & 0x1,\n          'FB': input[ip++] & 0x7,\n        };\n        info['carrier'] = {\n          'ML': input[ip] >> 5,\n          'VIV': (input[ip] >> 4) & 0x1,\n          'EG': (input[ip] >> 3) & 0x1,\n          'SUS': (input[ip] >> 2) & 0x1,\n          'RR': ((input[ip++] & 0x3) << 2) | (input[ip] >> 6),\n          'DR': (input[ip] >> 4) & 0xf,\n          'AR': ((input[ip++] & 0x3) << 2) | (input[ip] >> 6),\n          'SL': (input[ip] >> 4) & 0xf,\n          'TL': ((input[ip++] & 0x3) << 4) | (input[ip] >> 4),\n          'WF': (input[ip] >> 3) & 0x1,\n          'FB': input[ip++] & 0x7,\n        };\n        info['octaveSelect'] = input[ip++] & 0x3;\n\n        result.push(info);\n      }\n\n      return result;\n    };\n    /**\n     * @return {{part: number, switch: number}}\n     */\n    const parseVibrato = () => {\n      // const\n      if (input[ip++] !== 1) {\n        throw new Error('invalid Vibrato const value:' + input[ip - 1]);\n      }\n\n      return {\n        'part': (input[ip++] >> 5) & 0x3,\n        'switch': (input[ip++] >> 6),\n      };\n    };\n    /**\n     * @return {{data: ByteArray}}\n     */\n    const parseDeviceSpecific = () => {\n      /** @type {number} */\n      const length = (input[ip++] << 8) | input[ip++];\n      /** @type {number} */\n      const limit = ip + length;\n\n      // const\n      if (input[ip++] !== 0x11) {\n        throw new Error('invalid DeviceSpecific const value:' + input[ip - 1]);\n      }\n\n      return {\n        'data': input.subarray(ip, ip += limit - ip),\n      };\n    };\n\n    for (i = 0, il = this.header.numberOfTracks; i < il; ++i) {\n      signature =\n        String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]);\n\n      if (signature !== 'trac') {\n        throw new Error('invalid track signature:' + signature);\n      }\n\n      size =\n        (input[ip++] << 24) | (input[ip++] << 16) |\n        (input[ip++] << 8) | input[ip++];\n\n      limit = ip + size;\n\n      track = tracks[i] = [];\n\n      while (ip < limit) {\n        message = {\n          key: null,\n          length: null,\n          octaveShift: null,\n          subType: null,\n          type: null,\n          value: {},\n          velocity: null,\n          voice: null,\n        };\n\n        // delta time\n        message.deltaTime = deltaTime = input[ip++];\n\n        // status\n        status = input[ip++];\n        if (status !== 0xff) {\n          message.type = 'note';\n          message.subType = 'Note';\n          message.voice = status >> 6;\n          message.key = status & 0x3f;\n\n          // note length\n          noteLength = message.length = input[ip++];\n\n          // extend status\n          if (this.dataInformation.note === 1) {\n            extendStatus = input[ip++];\n            message.velocity = extendStatus >> 2;\n            message.octaveShift = extendStatus & 0x3;\n          }\n        } else {\n          message.type = 'meta';\n\n          // status\n          status = input[ip++];\n          switch (status >> 4) {\n            // system message\n            case 0xb:\n              switch (status & 0xf) {\n                case 0x0:\n                  message.subType = 'MasterVolume';\n                  message.value = input[ip++];\n                  break;\n                case 0xa:\n                  message.subType = 'DrumScale';\n                  message.value = {\n                    'channel': (input[ip] >> 3) & 0x7,\n                    'drum': input[ip++] & 0x1,\n                  };\n                  break;\n                default:\n                  throw new Error('unknown message type:' + status.toString(16));\n              }\n              break;\n            // tempo message\n            case 0xc:\n              message.subType = 'SetTempo';\n              message.value = {\n                'timeBase': (status & 0x7) === 7 ?\n                  NaN : Math.pow(2, status & 0x7) * ((status & 0x8) === 0 ? 6 : 15),\n                'tempo': input[ip++],\n              };\n              break;\n            // control message\n            case 0xd:\n              switch (status & 0xf) {\n                case 0x0:\n                  message.subType = 'Point';\n                  message.value = input[ip++];\n                  break;\n                case 0xd:\n                  message.subType = 'Loop';\n                  message.value = {\n                    'id': input[ip] >> 6,\n                    'count': input[ip] >> 2 & 0xf,\n                    'point': input[ip++] & 0x3,\n                  };\n                  break;\n                case 0xe:\n                  message.subType = 'Nop';\n                  message.value = input[ip++];\n                  break;\n                case 0xf:\n                  message.subType = 'EndOfTrack';\n                  message.value = input[ip++];\n                  break;\n                default:\n                  throw new Error('unkwnon message type:' + status.toString(16));\n              }\n              break;\n            // instrument\n            case 0xe:\n              switch (status & 0xf) {\n                case 0x0:\n                  message.subType = 'InstrumentLowPart';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'instrument': input[ip++] & 0x3f,\n                  };\n                  break;\n                case 0x1:\n                  message.subType = 'InstrumentHighPart';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'instrument': input[ip++] & 0x1,\n                  };\n                  break;\n                case 0x2:\n                  message.subType = 'Volume';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'volume': input[ip++] & 0x3f,\n                  };\n                  break;\n                case 0x3:\n                  message.subType = 'Valance';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'valance': input[ip++] & 0x3f,\n                  };\n                  break;\n                case 0x4:\n                  message.subType = 'PitchBend';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'value': input[ip++] & 0x3f,\n                  };\n                  break;\n                case 0x5:\n                  message.subType = 'ChannelAssign';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'channel': input[ip++] & 0x3f,\n                  };\n                  break;\n                case 0x6:\n                  message.subType = 'VolumeChange';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'volume': (input[ip++] & 0x3f) << 26 >> 26,\n                  };\n                  break;\n                case 0x7:\n                  message.subType = 'PitchBendRange';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'value': (input[ip++] & 0x3f),\n                  };\n                  break;\n\n\n                case 0x8:\n                /*\n                // TODO: 未遭遇\n                message.subType = 'MasterFineTuning';\n                message.value = {\n                  'part': input[ip] >> 6,\n                  'value': (input[ip++] & 0x3f)\n                };\n                break;\n                */\n                // TODO: あってるか自信ない\n                case 0x9:\n                  message.subType = 'MasterCoarseTuning';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'value': (input[ip++] & 0x3f),\n                  };\n                  break;\n                case 0xA:\n                  message.subType = 'Modulation';\n                  message.value = {\n                    'part': input[ip] >> 6,\n                    'depth': (input[ip++] & 0x3f),\n                  };\n                  break;\n                default:\n                  throw new Error('unkwnon message type:' + status.toString(16));\n              }\n              break;\n            // extended information\n            case 0xf:\n              switch (status & 0xf) {\n                case 0x0:\n                  message.subType = 'EditInstrument';\n                  message.value = parseEditInstrument();\n                  break;\n                case 0x1:\n                  message.subType = 'Vibrato';\n                  message.value = parseVibrato();\n                  break;\n                case 0xf:\n                  message.subType = 'DeviceSpecific';\n                  message.value = parseDeviceSpecific();\n                  break;\n                default:\n                  throw new Error('unkwnon message type:' + status.toString(16));\n              }\n              break;\n            default:\n              throw new Error('unkwnon message type:' + status.toString(16));\n          }\n        }\n\n        track.push(message);\n      }\n      ip = limit;\n    }\n\n    this.ip = ip;\n  }\n\n  /**\n   * @return {Object}\n   */\n  convertToMidiTracks() {\n    /** @type {Object} */\n    const result = {\n      timeDivision: this.timeDivision,\n      trac: [],\n      tracks: [],\n      plainTracks: [],\n    };\n    /** @type {Array.<Array.<Object>>} */\n    const tracks = result.tracks;\n    /** @type {Array.<Array.<Array.<number>>>} */\n    const plainTracks = result.plainTracks;\n    /** @type {Array.<Array.<Object>>} */\n    const mfiTracks = this.tracks;\n    /** @type {Array.<Object>} */\n    let mfiTrack;\n    /** @type {Object} */\n    let mfiEvent;\n    /** @type {Object} */\n    let prevEvent;\n    /** @type {Array.<Object>} */\n    let tmpTrack;\n    /** @type {number} */\n    let time;\n    /** @type {number} */\n    let pos;\n    /** @type {number} */\n    let key;\n    /** @type {number} */\n    let tmp;\n    /** @type {string} */\n    let str;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let jl;\n    /** @type {Array.<number>} */\n    const channelTime = [];\n    /** @type {number} */\n    let channel;\n\n    for (i = 0; i < 16; ++i) {\n      plainTracks[i] = [];\n      channelTime[i] = 0;\n    }\n\n    // 変換しにくい形式を平坦化する\n    for (i = 0, il = mfiTracks.length; i < il; ++i) {\n      mfiTrack = mfiTracks[i];\n      tmpTrack = [];\n\n      // note の処理\n      for (time = pos = j = 0, jl = mfiTrack.length; j < jl; ++j) {\n        mfiEvent = mfiTrack[j];\n        time += mfiEvent['deltaTime'];\n        mfiEvent['id'] = pos;\n        mfiEvent['time'] = time;\n\n        switch (mfiEvent['subType']) {\n          case 'Nop':\n            break;\n          case 'Note':\n            tmpTrack[pos++] = mfiEvent;\n            // TODO: value: ... 形式になおす\n            tmpTrack[pos] = {\n              'id': pos,\n              'type': 'internal',\n              'subType': 'NoteOff',\n              'time': time + mfiEvent['length'],\n              'key': mfiEvent['key'],\n              'voice': mfiEvent['voice'],\n              'velocity': mfiEvent['velocity'],\n              'octaveShift': mfiEvent['octaveShift'],\n            };\n            pos++;\n            break;\n          case 'InstrumentHighPart':\n            prevEvent = mfiEvent;\n            mfiEvent = mfiTrack[++j];\n            if (mfiEvent['subType'] !== 'InstrumentLowPart') {\n              throw new Error('broken instrument');\n            }\n            // TODO: value: ... 形式になおす\n            tmpTrack[pos] = {\n              'id': pos,\n              'type': 'internal',\n              'subType': 'ProgramChange',\n              'time': time,\n              'part': mfiEvent['value']['part'],\n              'instrument': (prevEvent['value']['instrument'] << 6) | mfiEvent['value']['instrument'],\n            };\n            pos++;\n            break;\n          default:\n            tmpTrack[pos++] = mfiEvent;\n            break;\n        }\n      }\n      tmpTrack.sort((a, b) => {\n        return a['time'] > b['time'] ? 1 : a['time'] < b['time'] ? -1 :\n          a['id'] > b['id'] ? 1 : a['id'] < b['id'] ? -1 :\n            0;\n      });\n\n      // MIDI トラックに作成\n      tracks[i] = [];\n      for (time = j = 0, jl = tmpTrack.length; j < jl; ++j) {\n        mfiEvent = tmpTrack[j];\n        time = mfiEvent['time'];\n\n        switch (mfiEvent['subType']) {\n          case 'Note':\n            // NoteOn: 9n kk vv\n            key = this.applyOctaveShift(mfiEvent['key'] + 45, mfiEvent['octaveShift']);\n            channel = i * 4 + mfiEvent['voice'];\n\n            // TODO: リズムトラックの時は Key が -10 されているような気がする\n            if (channel === 9) {\n              key -= 10;\n            }\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0x90 | channel,\n                key,\n                mfiEvent['velocity'] * 2\n              )\n            );\n            break;\n          case 'NoteOff':\n            // NoteOff: 8n kk vv\n            key = this.applyOctaveShift(mfiEvent['key'] + 45, mfiEvent['octaveShift']);\n            channel = i * 4 + mfiEvent['voice'];\n\n            // TODO: リズムトラックの時は Key が -10 されているような気がする\n            if (channel === 9) {\n              key -= 10;\n            }\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0x80 | channel,\n                key,\n                mfiEvent['velocity'] * 2\n              )\n            );\n            break;\n          case 'ProgramChange':\n            // Program Change: Cn pp\n            channel = i * 4 + mfiEvent['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xC0 | channel,\n                mfiEvent['instrument']\n              )\n            );\n            break;\n          case 'SetTempo':\n            // SetTempo: FF 51 03 tt tt tt\n            tmp = 2880000000 / (mfiEvent['value']['tempo'] * mfiEvent['value']['timeBase']);\n            channel = 0; // SetTempo は必ず先頭のトラックに配置する\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xFF,\n                0x51,\n                0x03,\n                (tmp >> 16) & 0xff, (tmp >> 8) & 0xff, tmp & 0xff\n              )\n            );\n            break;\n          case 'Loop':\n            // Marker: FF 06 ll ss ss ss ...\n            tmp = mfiEvent['value']['count'];\n            str = 'LOOP_' +\n              (mfiEvent['value']['point'] === 0 ? 'START' : 'END') +\n              '=ID:' + mfiEvent['value']['id'] +\n              ',COUNT:' + (tmp === 0 ? -1 : tmp);\n            channel = 0;\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                [\n                  0xFF,\n                  0x06,\n                  str.length,\n                ],\n                str.split('').map((a) => {\n                  return a.charCodeAt(0);\n                })\n              )\n            );\n            break;\n          case 'MasterVolume':\n            // Master Volume: F0 7F ee 04 01 dl dm F7\n            tmp = mfiEvent['value'];\n            channel = 0;\n\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xF0,\n                0x07, // length\n                0x7F, 0x7F, 0x04, 0x01, tmp, tmp, 0xF7\n              )\n            );\n            break;\n          case 'Modulation':\n            // CC#1 Modulation: Bn 01 dd\n            channel = i * 4 + mfiEvent['value']['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xB0 | channel,\n                0x01,\n                mfiEvent['value']['depth'] * 2\n              )\n            );\n            break;\n          case 'Volume':\n            // CC#7 Volume: Bn 07 dd\n            channel = i * 4 + mfiEvent['value']['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xB0 | channel,\n                0x07,\n                mfiEvent['value']['volume'] * 2\n              )\n            );\n            break;\n          case 'Valance':\n            // CC#10 Panpot: Bn 0A dd\n            channel = i * 4 + mfiEvent['value']['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xB0 | channel,\n                0x0A,\n                (mfiEvent['value']['valance'] - 32) * 2 + 64\n              )\n            );\n            break;\n          case 'PitchBend':\n            // Pitch Bend: En dl dm\n            // TODO: LSB = MSB で良いか不明\n            channel = i * 4 + mfiEvent['value']['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xE0 | channel,\n                mfiEvent['value']['value'] * 2,\n                mfiEvent['value']['value'] * 2\n              )\n            );\n            break;\n          case 'PitchBendRange':\n            // Pitch Bend: CC#100=0 CC#101=0 CC#6\n            // Bn 64 00 Bn 65 00 Bn 06 vv\n            channel = i * 4 + mfiEvent['value']['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xB0 | channel,\n                0x64, 0x00\n              ), [\n                0x00,\n                0xB0 | channel,\n                0x65, 0x00,\n              ], [\n                0x00,\n                0xB0 | channel,\n                0x06, mfiEvent['value']['value'] * 2,\n              ]\n            );\n            break;\n          case 'MasterCoarseTuning':\n            // MasterCoarseTuning: CC#100=0 CC#101=2 CC#6\n            // Bn 64 01 Bn 65 02 Bn 06 vv\n            channel = i * 4 + mfiEvent['value']['part'];\n            plainTracks[channel].push(\n              this.deltaTimeToByteArray(time - channelTime[channel]).concat(\n                0xB0 | channel,\n                0x64, 0x00\n              ), [\n                0x00,\n                0xB0 | channel,\n                0x65, 0x02,\n              ], [\n                0x00,\n                0xB0 | channel,\n                0x06, mfiEvent['value']['value'] * 2,\n              ]\n            );\n            break;\n          default:\n            continue;\n        }\n\n        channelTime[channel] = mfiEvent['time'];\n      }\n    }\n    return this.toSMF(plainTracks);\n  }\n\n  /**\n   * @param {number} key\n   * @param {number} octaveShift\n   * @return {number}\n   */\n  applyOctaveShift(key, octaveShift) {\n    /** @type {Array.<number>} */\n    const table = [0, 12, -24, -12];\n\n    if (table[octaveShift] !== void 0) {\n      return key + table[octaveShift];\n    }\n\n    throw new Error('invalid OctaveShift value:' + octaveShift);\n  }\n\n  /**\n   * @param {Array.<Array.<ByteArray>>} plainTracks\n   * @return {ByteArray}\n   */\n  toSMF(plainTracks) {\n    /** @type {number} @const */\n    const TimeDivision = 48;\n    /** @type {Array.<number>} */\n    let trackHeader;\n    /** @type {Array.<number>} */\n    let trackData;\n    /** @type {ByteArray} */\n    let result = [\n      0x4D, 0x54, 0x68, 0x64, // \"MThd\"\n      0x00, 0x00, 0x00, 0x06, // Size\n      0x00, 0x01, // Format\n      0x00, 0x10, // number of track\n      (TimeDivision >> 8) & 0xff, TimeDivision & 0xff, // Data\n    ];\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let jl;\n\n    /**\n     * @param {string} str\n     * @return {Array.<number>}\n     */\n    function stringToArray(str) {\n      /** @type {number} */\n      let i;\n      /** @type {number} */\n      const il = str.length;\n      /** @type {Array.<number>} */\n      const array = new Array(il);\n\n      for (i = 0; i < il; ++i) {\n        array[i] = str.charCodeAt(i);\n      }\n\n      return array;\n    }\n\n    if (this.dataInformation['copy'] !== void 0) {\n      /** @type {Array.<number>} */\n      let copy = stringToArray(this.dataInformation['copy']);\n\n      il = copy.length;\n      copy = [0x00, 0xff, 0x02].concat(\n        this.deltaTimeToByteArray(il),\n        copy\n      );\n      plainTracks[0].unshift(copy);\n    }\n\n    /*\n    if (this.dataInformation['titl'] !== void 0) {\n      let title = stringToArray(this.dataInformation['titl']);\n      il = title.length;\n      title = [0x00, 0xff, 0x03].concat(\n        this.deltaTimeToByteArray(il),\n        title\n      );\n      plainTracks[0].unshift(title);\n    }\n    */\n\n    for (i = 0, il = plainTracks.length; i < il; ++i) {\n      const track = plainTracks[i];\n      trackData = [];\n      for (j = 0, jl = track.length; j < jl; ++j) {\n        Array.prototype.push.apply(trackData, track[j]);\n      }\n\n      jl = trackData.length;\n      trackHeader = [\n        0x4D, 0x54, 0x72, 0x6B, // \"MTrk\"\n        (jl >> 24) & 0xff, (jl >> 16) & 0xff,\n        (jl >> 8) & 0xff, (jl) & 0xff,\n      ];\n      result = result.concat(trackHeader, trackData);\n    }\n\n    return new Uint8Array(result);\n  }\n\n  /**\n   * @param {number} deltaTime\n   * @return {Array.<number>}\n   */\n  deltaTimeToByteArray(deltaTime) {\n    /** @type {Array.<number>} */\n    const array = [];\n\n    while (deltaTime >= 0x80) {\n      array.unshift(deltaTime & 0x7f | (array.length === 0 ? 0 : 0x80));\n      deltaTime >>>= 7;\n    }\n    array.unshift(deltaTime | (array.length === 0 ? 0 : 0x80));\n\n    return array;\n  }\n}\n","import PSGConverter from './PSGConverter';\nimport MakiMabiSequence from './mms';\nimport { MetaEvent, ChannelEvent, SystemExclusiveEvent } from './midi_event';\n/**\n * @classdesc   MabiIcco MML File Parser\n *\n * @author      Logue <logue@hotmail.co.jp>\n * @copyright   2019 Logue <https://logue.dev/> All rights reserved.\n * @license     MIT\n */\nexport default class MabiIcco extends MakiMabiSequence {\n  /**\n   * @param {ByteArray} input\n   * @param {Object=} optParams\n   */\n  constructor(input, optParams = {}) {\n    super(input, optParams);\n    /** @type {array} */\n    this.input = String.fromCharCode.apply('', new Uint16Array(input)).split(/\\r\\n|\\r|\\n/);\n    /** @type {Array.<Array.<Object>>} 全トラックの演奏情報 */\n    this.tracks = [];\n    /** @type {Array.<Array.<Uint8Array>>} WMLに送る生のMIDIイベント */\n    this.plainTracks = [];\n    /** @param {number} トラック数 */\n    this.numberOfTracks = 1;\n    /** @type {number} 分解能 */\n    this.timeDivision = optParams.timeDivision || 96;\n  }\n  /**\n   * パース処理\n   */\n  parse() {\n    this.parseHeader();\n    this.parseTracks();\n    this.toPlainTrack();\n  };\n  /**\n   * ヘッダーメタ情報をパース\n   */\n  parseHeader() {\n    /** @type {TextEncoder} */\n    this.encoder = new TextEncoder('utf-8');\n\n    /** @type {array} 各トラックごと複数存在する変数名 */\n    const multipleKeys = ['mml-track', 'name', 'program', 'songProgram', 'panpot'];\n    const ret = {};\n    /** @type {number} */\n    let trackNo = -1;\n    ret.track = [];\n\n    for (let i = 0; i < this.input.length; i++) {\n      const line = this.input[i].trim();\n      if (i === 0) {\n        if (line !== '[mml-score]') {\n          throw new Error('Not MabiIcco File.');\n        }\n        continue;\n      }\n      const [key, value] = line.split('=');\n      if (multipleKeys.includes(key)) {\n        if (key === 'mml-track') {\n          trackNo++;\n          ret.track[trackNo] = {};\n          // -が含まれる名前を変数名として使うと面倒なので・・・。\n          ret.track[trackNo].mml = value;\n        } else {\n          ret.track[trackNo][key] = (key === 'name') ? value : value | 0;\n        }\n      } else {\n        ret[key] = value;\n      }\n    }\n    /** @param {string} タイトル */\n    this.title = ret.title;\n    /** @param {string} 著者情報 */\n    this.author = ret.author;\n    /** @param {array}  */\n    const mmiTempo = (ret.tempo !== '') ? ret.tempo.split('T') : [384, 120];\n    /** @param {number} 分解能（MabiIccoの場合、テンポの項目に含まれている？） */\n    this.timeDivision = mmiTempo[0] | 0 / 4;\n    /** @param {number} テンポ */\n    this.tempo = mmiTempo[1] | 0;\n    /** @param {array} 拍子記号 */\n    const timeSig = ret.time.split('/');\n    /** @type {array}  */\n    const headerTrack = [];\n    // GM Reset\n    headerTrack.push(new SystemExclusiveEvent('SystemExclusive', 0, 0, [0x7e, 0x7f, 0x09, 0x01]));\n    // 曲名と著者情報を付加\n    headerTrack.push(new MetaEvent('SequenceTrackName', 0, 0, [this.title]));\n    headerTrack.push(new MetaEvent('CopyrightNotice', 0, 0, [this.author]));\n    headerTrack.push(new MetaEvent('TimeSignature', 0, 0, [timeSig[0] | 0 || 4, timeSig[1] | 0 || 4, 0, 0]));\n    headerTrack.push(new MetaEvent('SetTempo', 0, 0, [Math.floor(60000000 / this.tempo)]));\n    headerTrack.push(new MetaEvent('EndOfTrack', 0, 0));\n    this.tracks.push(headerTrack);\n\n    this.input = ret.track;\n  };\n  /**\n   * MML parse\n   */\n  parseTracks() {\n    /** @type {array} MIDIイベント */\n    let track = [];\n    /** @type {array} 終了時間比較用 */\n    const endTimes = [];\n\n    for (let ch = 0; ch < this.input.length; ch++) {\n      const current = this.input[ch];\n      if (!current.mml.match(/^(?:MML@)(.*)/gm)) {\n        continue;\n      }\n\n      /** @param {array} MMLの配列（簡易マッチ） */\n      const mmls = RegExp.$1.split(',');\n\n      // 楽器名\n      track.push(new MetaEvent('InsturumentName', 0, 48, [current.name]));\n      // プログラムチェンジ\n      track.push(new ChannelEvent('ProgramChange', 0, 96, ch, current.program));\n      if (current.songProgram !== -1) {\n        // コーラス用\n        track.push(new ChannelEvent('ProgramChange', 0, 112, 15, current.songProgram));\n      }\n      // パン(CC:0x10)\n      track.push(new ChannelEvent('ControlChange', 0, 154, ch, 10, current.panpot));\n\n      // MMLの各チャンネルの処理\n      for (let chord = 0; chord < current.mml.length; chord++) {\n        if (chord === 3 && current.songProgram !== -1) {\n          // ch 16はコーラス用\n          ch = 15;\n        }\n        if (mmls[chord] === void 0) {\n          continue;\n        }\n\n        /** @param {PSGConverter} */\n        const mml2Midi = new PSGConverter({ timeDivision: this.timeDivision, channel: ch, timeOffset: 386, mml: mmls[chord] });\n        // トラックにマージ\n        track = track.concat(mml2Midi.events);\n        endTimes.push(mml2Midi.endTime);\n      }\n      // トラック終了\n      track.concat(new MetaEvent('EndOfTrack', 0, Math.max(endTimes)));\n      this.tracks.push(track);\n    }\n    this.numberOfTracks = this.tracks.length;\n  }\n}\n","import PSGConverter from './PSGConverter';\nimport Ini from 'ini';\nimport { MetaEvent, ChannelEvent, SystemExclusiveEvent } from './midi_event';\n/**\n * @classdesc   MakiMabi Sequence File Parser\n *\n * @author      Logue <logue@hotmail.co.jp>\n * @copyright   2019 Logue <https://logue.dev/> All rights reserved.\n * @license     MIT\n */\nexport default class MakiMabiSequence {\n  /**\n   * @param {ByteArray} input\n   * @param {Object=} optParams\n   */\n  constructor(input, optParams = {}) {\n    /** @type {string} */\n    const string = String.fromCharCode.apply('', new Uint16Array(input));\n    /** @type {Ini} MMSファイルをパースしたもの */\n    this.input = Ini.parse(string);\n    /** @type {Array.<Array.<Object>>} 全トラックの演奏情報 */\n    this.tracks = [];\n    /** @type {Array.<Array.<Uint8Array>>} WMLに送る生のMIDIイベント */\n    this.plainTracks = [];\n    /** @param {number} トラック数 */\n    this.numberOfTracks = 1;\n    /** @type {number} 分解能 */\n    this.timeDivision = optParams.timeDivision || 96;\n  }\n  /**\n   * パース処理\n   */\n  parse() {\n    this.parseHeader();\n    this.parseTracks();\n    this.toPlainTrack();\n  };\n  /**\n   * ヘッダーメタ情報をパース\n   */\n  parseHeader() {\n    /** @type {TextEncoder} */\n    this.encoder = new TextEncoder('shift_jis');\n    /** @type {object} インフォメーション情報 */\n    const header = this.input.infomation; // informationじゃない\n    /** @type {string} タイトル */\n    this.title = header.title;\n    /** @type {string} 著者情報 */\n    this.type = header.auther; // authorじゃない。\n    /** @param {number} 解像度 */\n    this.timeDivision = header.timeBase | 0 || 96;\n    /** @type {array} 楽器変換テーブル（MabiIccoのMMSFile.javaのテーブルを流用） */\n    this.mmsInstTable = [\n      0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n      10, 11, 12, 13, 14, 15, 16, 17, 65, 66,\n      67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\n      18,\n    ];\n\n    // 曲名と著者情報を付加\n\n    /** @type {array}  */\n    const headerTrack = [];\n    // GM Reset\n    headerTrack.push(new SystemExclusiveEvent('SystemExclusive', 0, 0, [0x7e, 0x7f, 0x09, 0x01]));\n    headerTrack.push(new MetaEvent('SequenceTrackName', 0, 0, [this.title]));\n    headerTrack.push(new MetaEvent('CopyrightNotice', 0, 0, [this.author]));\n    headerTrack.push(new MetaEvent('TimeSignature', 0, 0, [header.rythmNum | 0 || 4, header.rythmBase | 0 || 4, 0, 0]));\n    headerTrack.push(new MetaEvent('EndOfTrack', 0, 0));\n    this.tracks.push(headerTrack);\n\n    // infomationおよびmms-fileを取り除く\n    delete this.input['infomation'];\n    delete this.input['mms-file'];\n  };\n  /**\n   * MML parse\n   */\n  parseTracks() {\n    const input = this.input;\n    /** @type {array} MIDIイベント */\n    let track = [];\n    /** @type {array} 終了時間比較用 */\n    const endTimes = [];\n    /** @type {number} チャンネル */\n    let ch = 0;\n\n    for (const part in input) {\n      if (input.hasOwnProperty(part)) {\n        /** @param {array} MMLの配列 */\n        const mmls = [input[part].ch0_mml, input[part].ch1_mml, input[part].ch2_mml];\n        /** @param {number} パンポット */\n        const panpot = Number(input[part].panpot) + 64;\n\n        // 楽器名\n        track.push(new MetaEvent('InsturumentName', 0, 48, [input[part].name]));\n        // プログラムチェンジ\n        track.push(new ChannelEvent('ProgramChange', 0, 96, ch, this.mmsInstTable[input[part].instrument] | 0));\n        // パン\n        track.push(new ChannelEvent('ControlChange', 0, 154, ch, 10, panpot));\n\n        // MMLの各チャンネルの処理\n        for (let chord = 0; chord < mmls.length; chord++) {\n          /** @param {PSGConverter} */\n          const mml2Midi = new PSGConverter({ timeDivision: this.timeDivision, channel: ch, timeOffset: 386, mml: mmls[chord] });\n          // トラックにマージ\n          track = track.concat(mml2Midi.events);\n          endTimes.push(mml2Midi.endTime);\n        }\n        ch++;\n        // トラック終了\n        track.concat(new MetaEvent('EndOfTrack', 0, Math.max(endTimes)));\n        this.tracks.push(track);\n      }\n    }\n    this.numberOfTracks = this.tracks.length;\n  }\n\n  /**\n   * WebMidiLink信号に変換\n   */\n  toPlainTrack() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      /** @type {array} トラックのイベント*/\n      let rawTrackEvents = [];\n\n      /** @type {array} 全イベント */\n      let rawEvents = [];\n\n      /** @type {array} */\n      const events = this.tracks[i];\n\n      for (let j = 0; j < events.length; j++) {\n        /** @type {Event} イベント */\n        const event = events[j];\n        /** @var {Uint8Array} WebMidiLink信号 */\n        let raw;\n\n        if (event instanceof ChannelEvent) {\n          switch (event.subtype) {\n            case 'NoteOn':\n              // console.log(event);\n              if ((event).parameter2 === 0) {\n                raw = new Uint8Array([0x80 | event.channel, event.parameter1, event.parameter2]);\n              } else {\n                raw = new Uint8Array([0x90 | event.channel, event.parameter1, event.parameter2]);\n              }\n              break;\n            case 'NoteOff':\n              raw = new Uint8Array([0x80 | event.channel, event.parameter1, event.parameter2]);\n              break;\n            case 'ControlChange':\n              raw = new Uint8Array([0xB0 | event.channel, event.parameter1, event.parameter2]);\n              break;\n            case 'ProgramChange':\n              raw = new Uint8Array([0xC0 | event.channel, event.parameter1]);\n              break;\n          }\n        } else if (event instanceof MetaEvent) {\n          // Metaイベントの内容は実際使われない。単なる配列の数合わせのためのプレースホルダ（音を鳴らすことには関係ない処理だから）\n          /** @type {Uint8Array} */\n          const data = this.encoder.encode(event.data);\n          switch (event.subtype) {\n            case 'TextEvent':\n              raw = new Uint8Array([0xFF, 0x01].concat(data));\n              break;\n            case 'SequenceTrackName':\n              raw = new Uint8Array([0xFF, 0x03].concat(data));\n              break;\n            case 'CopyrightNotice':\n              raw = new Uint8Array([0xFF, 0x02].concat(data));\n              break;\n            case 'InsturumentName':\n              raw = new Uint8Array([0xFF, 0x04].concat(data));\n              break;\n            case 'SetTempo':\n              raw = new Uint8Array([0xFF, 0x51].concat(data));\n              break;\n            case 'TimeSignature':\n              raw = new Uint8Array([0xFF, 0x58].concat(data));\n              break;\n            case 'EndOfTrack':\n              raw = new Uint8Array([0xFF, 0x2F]);\n              break;\n          }\n        } else if (event instanceof SystemExclusiveEvent) {\n          raw = new Uint8Array([0xF0, 0x05].concat(event.data));\n        }\n        rawEvents = rawEvents.concat(raw);\n      }\n      rawTrackEvents = rawTrackEvents.concat(rawEvents);\n\n      this.plainTracks[i] = rawTrackEvents;\n    }\n  }\n}\n","import PSGConverter from './PSGConverter';\nimport MakiMabiSequence from './mms';\nimport { MetaEvent } from './midi_event';\n/**\n * @classdesc   MapleStory2 Mml Parser\n *\n * @author      Logue <logue@hotmail.co.jp>\n * @copyright   2019 Logue <https://logue.dev/> All rights reserved.\n * @license     MIT\n */\nexport default class MapleStory2Mml extends MakiMabiSequence {\n  /**\n   * @param {ByteArray} input\n   * @param {Object=} optParams\n   */\n  constructor(input, optParams = {}) {\n    super(input, optParams);\n    /** @type {TextEncoder} */\n    this.encoder = new TextEncoder('utf-8');\n    /** @type {DOMParser} */\n    const parser = new DOMParser();\n    /** @type {Document} */\n    const doc = parser.parseFromString(String.fromCharCode.apply('', new Uint16Array(input)), 'text/xml');\n    /** @param {Element} */\n    this.input = doc.querySelectorAll('ms2 > *');\n    /** @type {Array.<Array.<Object>>} 全トラックの演奏情報 */\n    this.tracks = [];\n    /** @type {Array.<Array.<Uint8Array>>} WMLに送る生のMIDIイベント */\n    this.plainTracks = [];\n    /** @param {number} トラック数 */\n    this.numberOfTracks = 1;\n    /** @type {number} 解像度 */\n    this.timeDivision = optParams.timeDivision || 96;\n  }\n  /**\n   */\n  parse() {\n    // this.parseHeader();\n    // this.parseDataInformation();\n    this.parseTracks();\n\n    this.toPlainTrack();\n\n    console.log(this);\n  };\n\n  /**\n   * MML parse\n   */\n  parseTracks() {\n    /** @type {array} MIDIイベント */\n    let track = [];\n    /** @type {array} 終了時間比較用 */\n    const endTimes = [];\n\n    for (let i = 0; i < this.input.length; i++) {\n      /** @param {PSGConverter} */\n      const mml2Midi = new PSGConverter({ timeDivision: this.timeDivision, channel: 0, mml: this.input[i].textContent.trim() });\n      track = track.concat(mml2Midi.events);\n      endTimes.push(mml2Midi.endTime);\n    }\n\n    // トラック終了\n    track.concat(new MetaEvent('EndOfTrack', 0, Math.max(endTimes)));\n    this.tracks.push(track);\n  }\n}\n","import SMF from './smf';\nimport Mld from './mld';\nimport MapleStory2Mml from './ms2mml';\nimport MakiMabiSequence from './mms';\nimport ThreeMacroLanguageEditor from './3mle';\nimport MabiIcco from './mmi';\n/**\n * Midi Player Class\n */\nexport class Player {\n  /**\n   * @param {string} target WML attach dom\n   */\n  constructor(target = '#wml') {\n    /** @type {number} */\n    this.tempo = 500000; // default\n    /** @type {HTMLIFrameElement} */\n    this.webMidiLink;\n    /** @type {number} */\n    this.resume;\n    /** @type {boolean} */\n    this.pause = true;\n    /** @type {boolean} */\n    this.ready = false;\n    /** @type {number} */\n    this.position = 0;\n    /** @type {Array.<Object>} */\n    this.track = [];\n    /** @type {number} */\n    this.timer = 0;\n    /** @type {Object} TODO: 最低限のプロパティは記述する */\n    this.sequence = {};\n    /** @type {boolean} */\n    this.enableCC111Loop = false;\n    /** @type {boolean} */\n    this.enableFalcomLoop = false;\n    /** @type {boolean} */\n    this.enableMFiLoop = false;\n    /** @type {boolean} */\n    this.enableLoop = false;\n    /** @type {number} */\n    this.tempoRate = 1;\n    /** @type {number} */\n    this.masterVolume = 16383;\n    /** @type {?string} */\n    this.textEvent = '';\n    /** @type {?string} */\n    this.sequenceName = '';\n    /** @type {?string} */\n    this.copyright = '';\n    /** @type {?string} */\n    this.lyrics = '';\n    /** @type {HTMLIFrameElement|Worker} */\n    this.webMidiLink = null;\n    /** @type {number} */\n    this.length = 0;\n    /** @type {number} */\n    this.time = 0;\n    /** @type {number} */\n    this.timeTotal;\n    /** @type {number} */\n    this.loaded = 0;\n    /** @type {Window} */\n    this.window = window;\n    /** @type {Element} */\n    this.target = this.window.document.querySelector(target);\n  }\n\n  /**\n   * @param {boolean} enable\n   */\n  setCC111Loop(enable) {\n    this.enableCC111Loop = enable;\n  }\n\n  /**\n   * @param {boolean} enable\n   */\n  setFalcomLoop(enable) {\n    this.enableFalcomLoop = enable;\n  }\n\n  /**\n   * @param {boolean} enable\n   */\n  setMFiLoop(enable) {\n    this.enableMFiLoop = enable;\n  }\n\n  /**\n   * @param {boolean} enable\n   */\n  setLoop(enable) {\n    this.enableLoop = enable;\n  }\n\n  /**\n   */\n  stop() {\n    /** @type {number} */\n    let i;\n\n    this.pause = true;\n    this.resume = Date.now();\n\n    if (this.webMidiLink) {\n      for (i = 0; i < 16; ++i) {\n        this.webMidiLink.contentWindow.postMessage('midi,b' + i.toString(16) + ',78,0', '*');\n      }\n    }\n  }\n\n  /**\n   * @return {HTMLIframeElement}\n   */\n  getWebMidiLink() {\n    return this.webMidiLink;\n  }\n\n  /**\n   */\n  init() {\n    this.stop();\n    this.initSequence();\n    this.pause = true;\n    this.track = null;\n    this.resume = -1;\n    this.text = null;\n    this.sequence = null;\n    this.sequenceName = null;\n    this.copyright = null;\n    this.lyrics = null;\n    this.textEvent = null;\n    this.length = 0;\n    this.position = 0;\n    this.time = 0;\n    this.timeTotal = 0;\n\n    this.window.clearTimeout(this.timer);\n\n    /** @type {Player} */\n    const player = this;\n    if (this.ready) {\n      this.sendInitMessage();\n    } else {\n      this.window.addEventListener('message', (ev) => {\n        if (ev.data === 'link,ready') {\n          player.sendInitMessage();\n        }\n      }, false);\n    }\n  };\n\n  /**\n   */\n  initSequence() {\n    this.tempo = 500000;\n    this.position = 0;\n\n    this.sendInitMessage();\n    this.pause = false;\n  }\n\n  /**\n   */\n  play() {\n    /** @type {Player} */\n    const player = this;\n\n    if (!this.webMidiLink) {\n      throw new Error('WebMidiLink not found');\n    }\n\n    if (this.ready) {\n      if (this.track) {\n        this.length = this.track.length;\n        if (this.track instanceof Array && this.position >= this.length) {\n          this.position = 0;\n        }\n        this.playSequence();\n      } else {\n        console.warn('Midi file is not loaded.');\n      }\n    } else {\n      this.window.addEventListener('message', (ev) => {\n        if (ev.data === 'link,ready') {\n          player.ready = true;\n          player.webMidiLink.style.height = this.webMidiLink.contentWindow.document.body.scrollHeight + 'px';\n          player.playSequence();\n        }\n      }, false);\n    }\n  };\n\n  /**\n   */\n  ended() {\n    player.window.postMessage('endoftrack', '*');\n  }\n\n  /**\n   */\n  sendInitMessage() {\n    /** @type {Window} */\n    const win = this.webMidiLink.contentWindow;\n    /** @type {number} */\n    let i;\n\n    for (i = 0; i < 16; ++i) {\n      // all sound off\n      win.postMessage('midi,b' + i.toString(16) + ',128,0', '*');\n      // volume\n      win.postMessage('midi,b' + i.toString(16) + ',07,64', '*');\n      // panpot\n      win.postMessage('midi,b' + i.toString(16) + ',0a,40', '*');\n      // pitch bend\n      win.postMessage('midi,e' + i.toString(16) + ',00,40', '*');\n      // pitch bend range\n      win.postMessage('midi,b' + i.toString(16) + ',64,00', '*');\n      win.postMessage('midi,b' + i.toString(16) + ',65,00', '*');\n      win.postMessage('midi,b' + i.toString(16) + ',06,02', '*');\n      win.postMessage('midi,b' + i.toString(16) + ',26,00', '*');\n    }\n    this.sendGmReset();\n  };\n\n  /**\n   * @param {string|Worker} port WebMidiLink url.\n   */\n  setWebMidiLink(port = './wml.html') {\n    /** @type {Player} */\n    const player = this;\n\n    const process = (ev) => {\n      if (typeof ev.data === 'string') {\n        const msg = ev.data.split(',');\n\n        if (msg[0] === 'link') {\n          // console.log(ev.data);\n          if (msg[1] === 'ready') {\n            player.ready = true;\n            player.loaded = 100;\n            player.setMasterVolume(player.masterVolume);\n          } else if (msg[1] === 'progress') {\n            // console.log(msg[2]);\n            player.loaded = Math.round((msg[2] / msg[3]) * 10000);\n          }\n        }\n      }\n    };\n\n    if (typeof port === 'string') {\n      // Clear self\n      if (this.webMidiLink) {\n        this.webMidiLink.parentNode.removeChild(this.webMidiLink);\n      }\n\n      // Clear parent DOM\n      if (this.target.firstChild) {\n        this.target.removeChild(this.target.firstChild);\n      }\n\n      /** @type {HTMLIFrameElement} */\n      const iframe = this.webMidiLink =\n        /** @type {HTMLIFrameElement} */\n        (this.window.document.createElement('iframe'));\n      iframe.src = port;\n      iframe.className = 'wml';\n\n      this.target.appendChild(iframe);\n      this.window.addEventListener('message', process, false);\n\n      const resizeHeight = () => {\n        iframe.style.height = this.webMidiLink.contentWindow.document.body.scrollHeight + 'px';\n      };\n\n      this.window.addEventListener('load', resizeHeight, false);\n\n      let timer = 0;\n      this.window.addEventListener('resize', () => {\n        if (timer > 0) {\n          clearTimeout(timer);\n        }\n        timer = setTimeout(resizeHeight, 100);\n      }, false);\n    } else {\n      // Worker Mode\n      this.webMidiLink.addEventListener('message', process, false);\n    }\n  };\n\n  /**\n   * @param {number} volume\n   */\n  setMasterVolume(volume) {\n    this.masterVolume = volume;\n\n    if (this.webMidiLink) {\n      this.webMidiLink.contentWindow.postMessage(\n        'midi,f0,7f,7f,04,01,' + [\n          ('0' + ((volume) & 0x7f).toString(16)).substr(-2),\n          ('0' + ((volume >> 7) & 0x7f).toString(16)).substr(-2),\n          '7f',\n        ].join(','),\n        '*'\n      );\n    }\n  };\n\n  /**\n   * @param {number} tempo\n   */\n  setTempoRate(tempo) {\n    this.tempoRate = tempo;\n  };\n\n  /**\n   */\n  playSequence() {\n    /** @type {Player} */\n    const player = this;\n    /** @type {number} */\n    const timeDivision = this.sequence.timeDivision;\n    /** @type {Array.<Object>} */\n    const mergedTrack = this.track;\n    /** @type {Window} */\n    const webMidiLink = this.webMidiLink.contentWindow;\n    /** @type {number} */\n    let pos = this.position || 0;\n    /** @type {Array.<?{pos: number}>} */\n    const mark = [];\n\n    const update = () => {\n      /** @type {number} */\n      const time = mergedTrack[pos]['time'];\n      /** @type {number} */\n      const length = mergedTrack.length;\n      /** @type {Object} TODO */\n      let event;\n      /** @type {?Array.<string>} */\n      let match;\n      /** @type {*} */\n      let tmp;\n      /** @type {number} */\n      let procTime = Date.now();\n\n      if (player.pause) {\n        player.resume = Date.now() - player.resume;\n        return;\n      }\n\n      do {\n        event = mergedTrack[pos]['event'];\n\n        switch (event.subtype) {\n          case 'TextEvent': // 0x01\n            // 主に歌詞などが入っている。MIDI作成者によってはデバッグ情報やお遊びも・・・。\n            player.textEvent = event.data[0];\n            break;\n          case 'Lyrics': // 0x05\n            // カラオケデーターが入っている。Textとの違いは、どの位置で表示するかやページ送りなどの制御コードが含まれている。\n            // とはいっても、単なるテキストデータ。\n            // KAR形式とYAMAHA独自のXF形式というカラオケ専用の書式がある。\n            // カラオケのパーサーは本プログラムでは実装しない。\n            // KAR形式：https://www.mixagesoftware.com/en/midikit/help/HTML/karaoke_formats.html\n            // XF形式：https://jp.yamaha.com/files/download/other_assets/7/321757/xfspc.pdf\n            player.lyrics = event.data[0];\n            break;\n          case 'Maker': // 0x06\n            if (player.enableFalcomLoop) {\n              // A-B Loop (Ys Eternal 2 Loop)\n              switch (event.data[0]) {\n                case 'A':\n                  mark[0] = {\n                    'pos': pos,\n                  };\n                  break;\n                case 'B':\n                  if (mark[0] && typeof mark[0]['pos'] === 'number') {\n                    pos = mark[0]['pos'];\n                    player.timer = player.window.setTimeout(update, 0);\n                    player.position = pos;\n                    return;\n                  }\n                  break;\n              }\n            }\n\n            if (player.enableMFiLoop) {\n              // MFi Loop\n              match = event.data[0].match(/^LOOP_(START|END)=ID:(\\d+),COUNT:(-?\\d+)$/);\n              if (match) {\n                if (match[1] === 'START') {\n                  mark[match[2] | 0] = mark[match[2]] || {\n                    'pos': pos,\n                    'count': match[3] | 0,\n                  };\n                } else if (match[1] === 'END' && player.enableMFiLoop) {\n                  tmp = mark[match[2] | 0];\n                  if (tmp['count'] !== 0) { // loop jump\n                    if (tmp['count'] > 0) {\n                      tmp['count']--;\n                    }\n                    pos = tmp['pos'];\n                    player.timer = player.window.setTimeout(update, 0);\n                    player.position = pos;\n                    return;\n                  } else { // loop end\n                    mark[match[2] | 0] = null;\n                  }\n                }\n              }\n            }\n            break;\n          case 'SetTempo': // 0x51\n            player.tempo = event.data[0];\n            break;\n        }\n\n\n        // CC#111 Loop\n        if (event.subtype === 'ControlChange' && event.parameter1 === 111) {\n          mark[0] = {\n            'pos': pos,\n          };\n        }\n\n        // send message\n        webMidiLink.postMessage(mergedTrack[pos++]['webMidiLink'], '*');\n      } while (pos < length && mergedTrack[pos]['time'] === time);\n\n      if (pos < length) {\n        procTime = Date.now() - procTime;\n        player.timer = player.window.setTimeout(\n          update,\n          player.tempo / (1000 * timeDivision) * (mergedTrack[pos]['time'] - time - procTime) * (1 / player.tempoRate)\n        );\n      } else {\n        // loop\n        player.ended();\n        player.pause = true;\n        if (player.enableCC111Loop && mark[0] && typeof mark[0]['pos'] === 'number') {\n          pos = mark[0]['pos'];\n        } else if (player.enableLoop) {\n          player.initSequence();\n          player.playSequence();\n        }\n      }\n\n      player.position = pos;\n      player.time = time;\n    };\n\n    if (!this.pause) {\n      this.timer = player.window.setTimeout(\n        update,\n        this.tempo / 1000 * timeDivision * this.track[0]['time']\n      );\n    } else {\n      // resume\n      this.timer = player.window.setTimeout(\n        update,\n        this.resume\n      );\n      this.pause = false;\n      this.resume = -1;\n    }\n  };\n\n  /**\n   * @param {ArrayBuffer} buffer\n   */\n  loadMidiFile(buffer) {\n    /** @type {SMF} */\n    const parser = new SMF(buffer);\n\n    this.init();\n    parser.parse();\n\n    this.mergeMidiTracks(parser);\n  };\n\n  /**\n   * @param {ArrayBuffer} buffer\n   */\n  loadMldFile(buffer) {\n    /** @type {Mld} */\n    const parser = new Mld(buffer);\n\n    this.init();\n    parser.parse();\n\n    this.mergeMidiTracks(parser.convertToMidiTracks());\n  }\n\n  /**\n   * @param {ArrayBuffer} buffer\n   */\n  loadMs2MmlFile(buffer) {\n    /** @type {MapleStory2Mml} */\n    const parser = new MapleStory2Mml(buffer);\n\n    this.init();\n    parser.parse();\n\n    this.mergeMidiTracks(parser);\n  }\n\n  /**\n   * @param {ArrayBuffer} buffer\n   */\n  loadMakiMabiSequenceFile(buffer) {\n    /** @type {MakiMabiSequence} */\n    const parser = new MakiMabiSequence(buffer);\n\n    this.init();\n    parser.parse();\n\n    this.mergeMidiTracks(parser);\n  }\n\n  /**\n   * @param {ArrayBuffer} buffer\n   */\n  load3MleFile(buffer) {\n    /** @type {ThreeMacroLanguageEditor} */\n    const parser = new ThreeMacroLanguageEditor(buffer);\n\n    this.init();\n    parser.parse();\n\n    this.mergeMidiTracks(parser);\n  }\n\n  /**\n   * @param {ArrayBuffer} buffer\n   */\n  loadMabiIccoFile(buffer) {\n    /** @type {MabiIcco} */\n    const parser = new MabiIcco(buffer);\n\n    this.init();\n    parser.parse();\n\n    this.mergeMidiTracks(parser);\n  }\n\n  /**\n   * @param {Object} midi\n   */\n  mergeMidiTracks(midi) {\n    /** @type {Array.<Object>} */\n    const mergedTrack = this.track = [];\n    /** @type {Array.<Array.<Object>>} */\n    const tracks = midi.tracks;\n    /** @type {Array.<number>} */\n    const trackPosition = new Array(tracks.length);\n    /** @type {Array.<Array.<Array.<number>>>} */\n    const plainTracks = midi.plainTracks;\n    /** @type {Array.<Object>} */\n    let track;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let jl;\n\n    // initialize\n    for (i = 0, il = tracks.length; i < il; ++i) {\n      trackPosition[i] = 0;\n    }\n\n    // merge\n    for (i = 0, il = tracks.length; i < il; ++i) {\n      track = tracks[i];\n      for (j = 0, jl = track.length; j < jl; ++j) {\n        if (midi.formatType === 0 || i === 0) {\n          // 著作権情報と曲名を取得\n          // SMF1のときは先頭のトラックから情報を取得する。\n          if (track[j].subtype === 'SequenceTrackName') {\n            this.sequenceName = track[j].data[0];\n          } else if (track[j].subtype === 'CopyrightNotice') {\n            this.copyright = track[j].data[0];\n          }\n        }\n\n        mergedTrack.push({\n          'track': i,\n          'eventId': j,\n          'time': track[j].time,\n          'event': track[j],\n          'webMidiLink': 'midi,' +\n            Array.prototype.map.call(\n              plainTracks[i][j],\n              (a) => {\n                return a.toString(16);\n              }\n            ).join(','),\n        });\n      }\n    }\n\n    // sort\n    mergedTrack.sort((a, b) => {\n      return a['time'] > b['time'] ? 1 : a['time'] < b['time'] ? -1 :\n        a['track'] > b['track'] ? 1 : a['track'] < b['track'] ? -1 :\n          a['eventId'] > b['eventId'] ? 1 : a['eventId'] < b['eventId'] ? -1 :\n            0;\n    });\n\n\n    // トータルの演奏時間\n    this.timeTotal = mergedTrack.slice(-1)[0].time;\n    this.sequence = midi;\n  };\n\n  /**\n   * @return {?string}\n   */\n  getSequenceName() {\n    return this.sequenceName;\n  };\n\n  /**\n   * @return {?string}\n   */\n  getCopyright() {\n    return this.copyright;\n  };\n\n  /**\n   * @return {?string}\n   */\n  getLyrics() {\n    return this.lyrics;\n  }\n\n  /**\n   * @return {?string}\n  */\n  getTextEvent() {\n    return this.textEvent;\n  }\n\n  /**\n   * @return {number}\n   */\n  getPosition() {\n    return this.position;\n  }\n\n  /**\n   * @param {number} pos\n   */\n  setPosition(pos) {\n    this.position = pos;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return this.length;\n  }\n\n  /**\n   */\n  sendGmReset() {\n    if (this.webMidiLink) {\n      // F0 7E 7F 09 01 F7\n      this.webMidiLink.contentWindow.postMessage('midi,F0,7E,7F,09,01,F7', '*');\n    }\n  }\n\n  /**\n   */\n  sendAllSoundOff() {\n    if (this.webMidiLink) {\n      this.webMidiLink.contentWindow.postMessage('midi,b0,78,0', '*');\n    }\n  }\n\n  /**\n   * TODO: ちゃんと動いていない\n   * @param {number} time\n   * @return {string}\n   */\n  getTime(time) {\n    const secs = (this.tempo / 6000000) * time;\n\n    const hours = Math.floor(secs / (60 * 60));\n\n    const divisorForMinutes = secs % (60 * 60);\n    const minutes = Math.floor(divisorForMinutes / 60);\n\n    const divisorForSeconds = divisorForMinutes % 60;\n    const seconds = Math.ceil(divisorForSeconds);\n\n    return hours + ':' + ('00' + minutes).slice(-2) + ':' + ('00' + seconds).slice(-2);\n  }\n}\n","/**\n * Riff Parser class\n */\nexport default class Riff {\n  /**\n   * @param {ByteArray} input input buffer.\n   * @param {Object=} optParams option parameters.\n   */\n  constructor(input, optParams = {}) {\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {number} */\n    this.ip = optParams['index'] || 0;\n    /** @type {number} */\n    this.length = optParams['length'] || input.length - this.ip;\n    /** @type {Array.<RiffChunk>} */\n    this.chunkList;\n    /** @type {number} */\n    this.offset = this.ip;\n    /** @type {boolean} */\n    this.padding =\n      optParams['padding'] !== void 0 ? optParams['padding'] : true;\n    /** @type {boolean} */\n    this.bigEndian =\n      optParams['bigEndian'] !== void 0 ? optParams['bigEndian'] : false;\n  }\n\n  /**\n   */\n  parse() {\n    /** @type {number} */\n    const length = this.length + this.offset;\n\n    this.chunkList = [];\n\n    while (this.ip < length) {\n      this.parseChunk();\n    }\n  }\n\n  /**\n   */\n  parseChunk() {\n    /** @type {ByteArray} */\n    const input = this.input;\n    /** @type {number} */\n    let ip = this.ip;\n    /** @type {number} */\n    let size;\n\n    this.chunkList.push(new RiffChunk(\n      String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]),\n      (size = this.bigEndian ?\n        ((input[ip++] << 24) | (input[ip++] << 16) |\n          (input[ip++] << 8) | (input[ip++])) >>> 0 :\n        ((input[ip++]) | (input[ip++] << 8) |\n          (input[ip++] << 16) | (input[ip++] << 24)) >>> 0\n      ),\n      ip\n    ));\n\n    ip += size;\n\n    // padding\n    if (this.padding && ((ip - this.offset) & 1) === 1) {\n      ip++;\n    }\n\n    this.ip = ip;\n  }\n\n  /**\n   * @param {number} index chunk index.\n   * @return {?RiffChunk}\n   */\n  getChunk(index) {\n    /** @type {RiffChunk} */\n    const chunk = this.chunkList[index];\n\n    if (chunk === void 0) {\n      return null;\n    }\n\n    return chunk;\n  }\n\n  /**\n   * @return {number}\n   */\n  getNumberOfChunks() {\n    return this.chunkList.length;\n  }\n}\n\n/**\n * Riff Chunk Structure\n * @interface\n */\nclass RiffChunk {\n  /**\n   * @param {string} type\n   * @param {number} size\n   * @param {number} offset\n   */\n  constructor(type, size, offset) {\n    /** @type {string} */\n    this.type = type;\n    /** @type {number} */\n    this.size = size;\n    /** @type {number} */\n    this.offset = offset;\n  }\n}\n","import Riff from './riff';\nimport {\n  ChannelEvent,\n  SystemExclusiveEvent,\n  MetaEvent,\n} from './midi_event';\n\n/**\n * Standard Midi File Parser class\n */\nexport default class SMF {\n  /**\n   * @param {ByteArray} input input buffer.\n   * @param {Object=} optParams option parameters.\n   */\n  constructor(input, optParams = {}) {\n    optParams.padding = false;\n    optParams.bigEndian = true;\n\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {number} */\n    this.ip = optParams.index || 0;\n    /** @type {number} */\n    this.chunkIndex = 0;\n    /**\n     * @type {Riff}\n     * @private\n     */\n    this.riffParser_ = new Riff(input, optParams);\n\n    // MIDI File Information\n\n    /** @type {number} */\n    this.formatType = 0;\n    /** @type {number} */\n    this.numberOfTracks = 0;\n    /** @type {number} */\n    this.timeDivision = 0;\n    /** @type {Array.<Array.<Midi.Event>>} */\n    this.tracks = [];\n    /** @type {Array.<Array.<ByteArray>>} */\n    this.plainTracks = [];\n  };\n\n  /**\n   */\n  parse() {\n    /** @type {number} */\n    let i = 0;\n    /** @type {number} */\n    let il = 0;\n\n    // parse riff chunks\n    this.riffParser_.parse();\n\n    // parse header chunk\n    this.parseHeaderChunk();\n\n    // parse track chunks\n    for (i = 0, il = this.numberOfTracks; i < il; ++i) {\n      this.parseTrackChunk();\n    }\n  };\n\n  /**\n   */\n  parseHeaderChunk() {\n    /** @type {?{type: string, size: number, offset: number}} */\n    const chunk = this.riffParser_.getChunk(this.chunkIndex++);\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n\n    if (!chunk || chunk.type !== 'MThd') {\n      throw new Error('invalid header signature');\n    }\n\n    this.formatType = (data[ip++] << 8) | data[ip++];\n    this.numberOfTracks = (data[ip++] << 8) | data[ip++];\n    this.timeDivision = (data[ip++] << 8) | data[ip++];\n  };\n\n  /**\n   */\n  parseTrackChunk() {\n    /** @type {?{type: string, size: number, offset: number}} */\n    const chunk = this.riffParser_.getChunk(this.chunkIndex++);\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {number} */\n    let size = 0;\n    /** @type {number} */\n    let deltaTime = 0;\n    /** @type {number} */\n    let eventType = 0;\n    /** @type {number} */\n    let channel = 0;\n    /** @type {number} */\n    let prevEventType = -1;\n    /** @type {number} */\n    let prevChannel = -1;\n    /** @type {number} */\n    let tmp = 0;\n    /** @type {number} */\n    let totalTime = 0;\n    /** @type {number} */\n    let offset = 0;\n    /** @type {number} */\n    let length = 0;\n    /** @type {number} */\n    let status = 0;\n    /** @type {Event} */\n    let event;\n    /** @type {ByteArray} */\n    let plainBytes;\n\n    /** @return {number} */\n    const readNumber = () => {\n      /** @type {number} */\n      let result = 0;\n      /** @type {number} */\n      let tmp = 0;\n\n      do {\n        tmp = data[ip++];\n        result = (result << 7) | (tmp & 0x7f);\n      } while ((tmp & 0x80) !== 0);\n\n      return result;\n    };\n\n    if (!chunk || chunk.type !== 'MTrk') {\n      throw new Error('invalid header signature');\n    }\n\n    size = chunk.offset + chunk.size;\n    const eventQueue = [];\n    const plainQueue = [];\n\n    while (ip < size) {\n      // delta time\n      deltaTime = readNumber();\n      totalTime += deltaTime;\n\n      // offset\n      offset = ip;\n\n      // event type value, midi channel\n      status = data[ip++];\n      eventType = (status >> 4) & 0xf;\n      channel = status & 0xf;\n\n      // run status rule\n      if (eventType < 8) {\n        eventType = prevEventType;\n        channel = prevChannel;\n        status = (prevEventType << 4) | prevChannel;\n        ip--;\n        offset--;\n      } else {\n        prevEventType = eventType;\n        prevChannel = channel;\n      }\n\n      // TODO\n      const table = [, , , , , , , ,\n        'NoteOff', // 0x8\n        'NoteOn',\n        'NoteAftertouch',\n        'ControlChange',\n        'ProgramChange',\n        'ChannelAftertouch',\n        'PitchBend',\n      ];\n\n      switch (eventType) {\n        // channel events\n        case 0x8:\n        /* FALLTHROUGH */\n        case 0x9:\n        /* FALLTHROUGH */\n        case 0xA:\n        /* FALLTHROUGH */\n        case 0xB:\n        /* FALLTHROUGH */\n        case 0xD:\n        /* FALLTHROUGH */\n        case 0xE:\n          event = new ChannelEvent(\n            table[eventType], deltaTime, totalTime,\n            channel, data[ip++], data[ip++]\n          );\n          break;\n        case 0xC:\n          event = new ChannelEvent(\n            table[eventType], deltaTime, totalTime,\n            channel, data[ip++]\n          );\n          break;\n        // meta events, system exclusive event\n        case 0xF:\n          switch (channel) {\n            // SysEx event\n            case 0x0:\n              tmp = readNumber();\n              if (data[ip + tmp - 1] !== 0xf7) {\n                throw new Error('invalid SysEx event');\n              }\n              event = new SystemExclusiveEvent(\n                'SystemExclusive', deltaTime, totalTime,\n                data.subarray(ip, (ip += tmp) - 1)\n              );\n              break;\n            case 0x7:\n              tmp = readNumber();\n              event = new SystemExclusiveEvent(\n                'SystemExclusive(F7)', deltaTime, totalTime,\n                data.subarray(ip, (ip += tmp))\n              );\n              break;\n            // meta event\n            case 0xF:\n              eventType = data[ip++];\n              tmp = readNumber();\n              switch (eventType) {\n                case 0x00: // sequence number\n                  event = new MetaEvent(\n                    'SequenceNumber', deltaTime, totalTime, [data[ip++], data[ip++]]\n                  );\n                  break;\n                case 0x01: // text event\n                  event = new MetaEvent(\n                    'TextEvent', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x02: // copyright notice\n                  event = new MetaEvent(\n                    'CopyrightNotice', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x03: // sequence/track name\n                  event = new MetaEvent(\n                    'SequenceTrackName', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x04: // instrument name\n                  event = new MetaEvent(\n                    'InstrumentName', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x05: // lyrics\n                  event = new MetaEvent(\n                    'Lyrics', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x06: // marker\n                  event = new MetaEvent(\n                    'Marker', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x07: // cue point\n                  event = new MetaEvent(\n                    'CuePoint', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x20: // midi channel prefix\n                  event = new MetaEvent(\n                    'MidiChannelPrefix', deltaTime, totalTime, [data[ip++]]\n                  );\n                  break;\n                case 0x2f: // end of track\n                  event = new MetaEvent(\n                    'EndOfTrack', deltaTime, totalTime, []\n                  );\n                  break;\n                case 0x51: // set tempo\n                  event = new MetaEvent(\n                    'SetTempo', deltaTime, totalTime, [(data[ip++] << 16) | (data[ip++] << 8) | data[ip++]]\n                  );\n                  break;\n                case 0x54: // smpte offset\n                  event = new MetaEvent(\n                    'SmpteOffset', deltaTime, totalTime, [data[ip++], data[ip++], data[ip++], data[ip++], data[ip++]]\n                  );\n                  break;\n                case 0x58: // time signature\n                  event = new MetaEvent(\n                    'TimeSignature', deltaTime, totalTime, [data[ip++], data[ip++], data[ip++], data[ip++]]\n                  );\n                  break;\n                case 0x59: // key signature\n                  event = new MetaEvent(\n                    'KeySignature', deltaTime, totalTime, [data[ip++], data[ip++]]\n                  );\n                  break;\n                case 0x7f: // sequencer specific\n                  event = new MetaEvent(\n                    'SequencerSpecific', deltaTime, totalTime, [data.subarray(ip, ip += tmp)]\n                  );\n                  break;\n                default: // unknown\n                  event = new MetaEvent(\n                    'Unknown', deltaTime, totalTime, [eventType, data.subarray(ip, ip += tmp)]\n                  );\n              }\n              break;\n            default:\n              console.warn('unknown message:', status.toString(16));\n          }\n          break;\n        // error\n        default:\n          throw new Error('invalid status');\n      }\n\n      // plain queue\n      length = ip - offset;\n      plainBytes = data.subarray(offset, offset + length);\n      plainBytes[0] = status;\n      if (\n        event instanceof ChannelEvent &&\n        event.subtype === 'NoteOn' &&\n        /** @type {ChannelEvent} */\n        (event).parameter2 === 0\n      ) {\n        event.subtype = table[8];\n        plainBytes = new Uint8Array([0x80 | event.channel, event.parameter1, event.parameter2]);\n      }\n      plainQueue.push(plainBytes);\n\n      // event queue\n      eventQueue.push(event);\n    }\n\n    this.tracks.push(eventQueue);\n    this.plainTracks.push(plainQueue);\n  };\n};\n"],"sourceRoot":""}