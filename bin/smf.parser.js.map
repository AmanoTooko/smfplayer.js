{"version":3,"sources":["webpack://SMF/webpack/universalModuleDefinition","webpack://SMF/webpack/bootstrap","webpack://SMF/./src/midi_event.js","webpack://SMF/./src/riff.js","webpack://SMF/./src/smf.js"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,mBAAmB;AAClC;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;;AAME;;;;;;;;;;;;;ACnFF;AAAA;AAAA;AACA;AACA;AACe;AACf;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,kBAAkB;AACjC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,eAAe,UAAU;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;;;;;;;;;;;;;AChHA;AAAA;AAAA;AAAA;AAA0B;AAKJ;;AAEtB;AACA;AACA;AACe;AACf;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC;AACA;;AAEA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA,cAAc;AACd;AACA;AACA,2BAA2B,6CAAI;;AAE/B;;AAEA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,2BAA2B;AAC1C;AACA,eAAe,0BAA0B;AACzC;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,EAAE,4CAA4C;AAC7D;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,EAAE,4CAA4C;AAC7D;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,MAAM;AACrB;AACA,eAAe,UAAU;AACzB;;AAEA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAY;AAClC;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAY;AACrC;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"smf.parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SMF\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SMF\"] = factory();\n\telse\n\t\troot[\"SMF\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/smf.js\");\n","/**\n * Midi Event abstract Structure\n */\nclass Event {\n  /**\n   * @param {string} subtype event subtype name.\n   * @param {number} deltaTime delta time.\n   * @param {number} time time.\n   */\n  constructor(subtype, deltaTime, time) {\n    /** @type {string} */\n    this.subtype = subtype;\n    /** @type {number} */\n    this.deltaTime = deltaTime;\n    /** @type {number} */\n    this.time = time;\n  }\n}\n\n/**\n * Midi Channel Event Structure\n * @extends {Event}\n */\nclass ChannelEvent extends Event {\n  /**\n   * @param {string} subtype\n   * @param {number} deltaTime delta time.\n   * @param {number} time time.\n   * @param {number} channel\n   * @param {number=} optParameter1\n   * @param {number=} optParameter2\n   */\n  constructor(subtype, deltaTime, time, channel, optParameter1, optParameter2) {\n    super(subtype, deltaTime, time);\n    /** @type {number} */\n    this.channel = channel;\n    /** @type {(number|undefined)} */\n    this.parameter1 = optParameter1;\n    /** @type {(number|undefined)} */\n    this.parameter2 = optParameter2;\n  }\n}\n\n/**\n * System Exclusive Event Structure\n * @extends {Event}\n */\nclass SystemExclusiveEvent extends Event {\n  /**\n   * @param {string} subtype\n   * @param {number} deltaTime delta time.\n   * @param {number} time time.\n   * @param {ByteArray} data\n   */\n  constructor(subtype, deltaTime, time, data) {\n    super(subtype, deltaTime, time);\n    /** @type {ByteArray} */\n    this.data = data;\n  }\n}\n\n/**\n * Midi Meta Event Structure\n * @extends {Event}\n */\nclass MetaEvent extends Event {\n  /**\n   * @param {string} subtype\n   * @param {number} deltaTime delta time.\n   * @param {number} time time.\n   * @param {Array.<*>} data meta data.\n   */\n  constructor(subtype, deltaTime, time, data) {\n    super(subtype, deltaTime, time);\n    /** @type {Array.<*>} */\n    this.data = data;\n  };\n}\n\nexport {\n  ChannelEvent,\n  SystemExclusiveEvent,\n  MetaEvent,\n};\n","/**\n * Riff Parser class\n */\nexport default class Riff {\n  /**\n   * @param {ByteArray} input input buffer.\n   * @param {Object=} optParams option parameters.\n   */\n  constructor(input, optParams = {}) {\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {number} */\n    this.ip = optParams['index'] || 0;\n    /** @type {number} */\n    this.length = optParams['length'] || input.length - this.ip;\n    /** @type {Array.<RiffChunk>} */\n    this.chunkList;\n    /** @type {number} */\n    this.offset = this.ip;\n    /** @type {boolean} */\n    this.padding =\n      optParams['padding'] !== void 0 ? optParams['padding'] : true;\n    /** @type {boolean} */\n    this.bigEndian =\n      optParams['bigEndian'] !== void 0 ? optParams['bigEndian'] : false;\n  }\n\n  /**\n   */\n  parse() {\n    /** @type {number} */\n    const length = this.length + this.offset;\n\n    this.chunkList = [];\n\n    while (this.ip < length) {\n      this.parseChunk();\n    }\n  }\n\n  /**\n   */\n  parseChunk() {\n    /** @type {ByteArray} */\n    const input = this.input;\n    /** @type {number} */\n    let ip = this.ip;\n    /** @type {number} */\n    let size;\n\n    this.chunkList.push(new RiffChunk(\n      String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]),\n      (size = this.bigEndian ?\n        ((input[ip++] << 24) | (input[ip++] << 16) |\n          (input[ip++] << 8) | (input[ip++])) >>> 0 :\n        ((input[ip++]) | (input[ip++] << 8) |\n          (input[ip++] << 16) | (input[ip++] << 24)) >>> 0\n      ),\n      ip\n    ));\n\n    ip += size;\n\n    // padding\n    if (this.padding && ((ip - this.offset) & 1) === 1) {\n      ip++;\n    }\n\n    this.ip = ip;\n  }\n\n  /**\n   * @param {number} index chunk index.\n   * @return {?RiffChunk}\n   */\n  getChunk(index) {\n    /** @type {RiffChunk} */\n    const chunk = this.chunkList[index];\n\n    if (chunk === void 0) {\n      return null;\n    }\n\n    return chunk;\n  }\n\n  /**\n   * @return {number}\n   */\n  getNumberOfChunks() {\n    return this.chunkList.length;\n  }\n}\n\n/**\n * Riff Chunk Structure\n * @interface\n */\nclass RiffChunk {\n  /**\n   * @param {string} type\n   * @param {number} size\n   * @param {number} offset\n   */\n  constructor(type, size, offset) {\n    /** @type {string} */\n    this.type = type;\n    /** @type {number} */\n    this.size = size;\n    /** @type {number} */\n    this.offset = offset;\n  }\n}\n","import Riff from './riff';\nimport {\n  ChannelEvent,\n  SystemExclusiveEvent,\n  MetaEvent,\n} from './midi_event';\n\n/**\n * Standard Midi File Parser class\n */\nexport default class SMF {\n  /**\n   * @param {ByteArray} input input buffer.\n   * @param {Object=} optParams option parameters.\n   */\n  constructor(input, optParams = {}) {\n    optParams.padding = false;\n    optParams.bigEndian = true;\n\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {number} */\n    this.ip = optParams.index || 0;\n    /** @type {number} */\n    this.chunkIndex = 0;\n    /**\n     * @type {Riff}\n     * @private\n     */\n    this.riffParser_ = new Riff(input, optParams);\n\n    // MIDI File Information\n\n    /** @type {number} */\n    this.formatType = 0;\n    /** @type {number} */\n    this.numberOfTracks = 0;\n    /** @type {number} */\n    this.timeDivision = 0;\n    /** @type {Array.<Array.<Midi.Event>>} */\n    this.tracks = [];\n    /** @type {Array.<Array.<ByteArray>>} */\n    this.plainTracks = [];\n  };\n\n  /**\n   */\n  parse() {\n    /** @type {number} */\n    let i = 0;\n    /** @type {number} */\n    let il = 0;\n\n    // parse riff chunks\n    this.riffParser_.parse();\n\n    // parse header chunk\n    this.parseHeaderChunk();\n\n    // parse track chunks\n    for (i = 0, il = this.numberOfTracks; i < il; ++i) {\n      this.parseTrackChunk();\n    }\n  };\n\n  /**\n   */\n  parseHeaderChunk() {\n    /** @type {?{type: string, size: number, offset: number}} */\n    const chunk = this.riffParser_.getChunk(this.chunkIndex++);\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n\n    if (!chunk || chunk.type !== 'MThd') {\n      throw new Error('invalid header signature');\n    }\n\n    this.formatType = (data[ip++] << 8) | data[ip++];\n    this.numberOfTracks = (data[ip++] << 8) | data[ip++];\n    this.timeDivision = (data[ip++] << 8) | data[ip++];\n  };\n\n  /**\n   */\n  parseTrackChunk() {\n    /** @type {?{type: string, size: number, offset: number}} */\n    const chunk = this.riffParser_.getChunk(this.chunkIndex++);\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {number} */\n    let size = 0;\n    /** @type {number} */\n    let deltaTime = 0;\n    /** @type {number} */\n    let eventType = 0;\n    /** @type {number} */\n    let channel = 0;\n    /** @type {number} */\n    let prevEventType = -1;\n    /** @type {number} */\n    let prevChannel = -1;\n    /** @type {number} */\n    let tmp = 0;\n    /** @type {number} */\n    let totalTime = 0;\n    /** @type {number} */\n    let offset = 0;\n    /** @type {number} */\n    let length = 0;\n    /** @type {number} */\n    let status = 0;\n    /** @type {Event} */\n    let event;\n    /** @type {ByteArray} */\n    let plainBytes;\n\n    /** @return {number} */\n    const readNumber = () => {\n      /** @type {number} */\n      let result = 0;\n      /** @type {number} */\n      let tmp = 0;\n\n      do {\n        tmp = data[ip++];\n        result = (result << 7) | (tmp & 0x7f);\n      } while ((tmp & 0x80) !== 0);\n\n      return result;\n    };\n\n    if (!chunk || chunk.type !== 'MTrk') {\n      throw new Error('invalid header signature');\n    }\n\n    size = chunk.offset + chunk.size;\n    const eventQueue = [];\n    const plainQueue = [];\n\n    while (ip < size) {\n      // delta time\n      deltaTime = readNumber();\n      totalTime += deltaTime;\n\n      // offset\n      offset = ip;\n\n      // event type value, midi channel\n      status = data[ip++];\n      eventType = (status >> 4) & 0xf;\n      channel = status & 0xf;\n\n      // run status rule\n      if (eventType < 8) {\n        eventType = prevEventType;\n        channel = prevChannel;\n        status = (prevEventType << 4) | prevChannel;\n        ip--;\n        offset--;\n      } else {\n        prevEventType = eventType;\n        prevChannel = channel;\n      }\n\n      // TODO\n      const table = [, , , , , , , ,\n        'NoteOff', // 0x8\n        'NoteOn',\n        'NoteAftertouch',\n        'ControlChange',\n        'ProgramChange',\n        'ChannelAftertouch',\n        'PitchBend',\n      ];\n\n      switch (eventType) {\n        // channel events\n        case 0x8:\n        /* FALLTHROUGH */\n        case 0x9:\n        /* FALLTHROUGH */\n        case 0xA:\n        /* FALLTHROUGH */\n        case 0xB:\n        /* FALLTHROUGH */\n        case 0xD:\n        /* FALLTHROUGH */\n        case 0xE:\n          event = new ChannelEvent(\n            table[eventType], deltaTime, totalTime,\n            channel, data[ip++], data[ip++]\n          );\n          break;\n        case 0xC:\n          event = new ChannelEvent(\n            table[eventType], deltaTime, totalTime,\n            channel, data[ip++]\n          );\n          break;\n        // meta events, system exclusive event\n        case 0xF:\n          switch (channel) {\n            // SysEx event\n            case 0x0:\n              tmp = readNumber();\n              if (data[ip + tmp - 1] !== 0xf7) {\n                throw new Error('invalid SysEx event');\n              }\n              event = new SystemExclusiveEvent(\n                'SystemExclusive', deltaTime, totalTime,\n                data.subarray(ip, (ip += tmp) - 1)\n              );\n              break;\n            case 0x7:\n              tmp = readNumber();\n              event = new SystemExclusiveEvent(\n                'SystemExclusive(F7)', deltaTime, totalTime,\n                data.subarray(ip, (ip += tmp))\n              );\n              break;\n            // meta event\n            case 0xF:\n              eventType = data[ip++];\n              tmp = readNumber();\n              switch (eventType) {\n                case 0x00: // sequence number\n                  event = new MetaEvent(\n                    'SequenceNumber', deltaTime, totalTime, [data[ip++], data[ip++]]\n                  );\n                  break;\n                case 0x01: // text event\n                  event = new MetaEvent(\n                    'TextEvent', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x02: // copyright notice\n                  event = new MetaEvent(\n                    'CopyrightNotice', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x03: // sequence/track name\n                  event = new MetaEvent(\n                    'SequenceTrackName', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x04: // instrument name\n                  event = new MetaEvent(\n                    'InstrumentName', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x05: // lyrics\n                  event = new MetaEvent(\n                    'Lyrics', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x06: // marker\n                  event = new MetaEvent(\n                    'Marker', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x07: // cue point\n                  event = new MetaEvent(\n                    'CuePoint', deltaTime, totalTime, [String.fromCharCode.apply(null, data.subarray(ip, ip += tmp))]\n                  );\n                  break;\n                case 0x20: // midi channel prefix\n                  event = new MetaEvent(\n                    'MidiChannelPrefix', deltaTime, totalTime, [data[ip++]]\n                  );\n                  break;\n                case 0x2f: // end of track\n                  event = new MetaEvent(\n                    'EndOfTrack', deltaTime, totalTime, []\n                  );\n                  break;\n                case 0x51: // set tempo\n                  event = new MetaEvent(\n                    'SetTempo', deltaTime, totalTime, [(data[ip++] << 16) | (data[ip++] << 8) | data[ip++]]\n                  );\n                  break;\n                case 0x54: // smpte offset\n                  event = new MetaEvent(\n                    'SmpteOffset', deltaTime, totalTime, [data[ip++], data[ip++], data[ip++], data[ip++], data[ip++]]\n                  );\n                  break;\n                case 0x58: // time signature\n                  event = new MetaEvent(\n                    'TimeSignature', deltaTime, totalTime, [data[ip++], data[ip++], data[ip++], data[ip++]]\n                  );\n                  break;\n                case 0x59: // key signature\n                  event = new MetaEvent(\n                    'KeySignature', deltaTime, totalTime, [data[ip++], data[ip++]]\n                  );\n                  break;\n                case 0x7f: // sequencer specific\n                  event = new MetaEvent(\n                    'SequencerSpecific', deltaTime, totalTime, [data.subarray(ip, ip += tmp)]\n                  );\n                  break;\n                default: // unknown\n                  event = new MetaEvent(\n                    'Unknown', deltaTime, totalTime, [eventType, data.subarray(ip, ip += tmp)]\n                  );\n              }\n              break;\n            default:\n              console.warn('unknown message:', status.toString(16));\n          }\n          break;\n        // error\n        default:\n          throw new Error('invalid status');\n      }\n\n      // plain queue\n      length = ip - offset;\n      plainBytes = data.subarray(offset, offset + length);\n      plainBytes[0] = status;\n      if (\n        event instanceof ChannelEvent &&\n        event.subtype === 'NoteOn' &&\n        /** @type {ChannelEvent} */\n        (event).parameter2 === 0\n      ) {\n        event.subtype = table[8];\n        plainBytes = new Uint8Array([0x80 | event.channel, event.parameter1, event.parameter2]);\n      }\n      plainQueue.push(plainBytes);\n\n      // event queue\n      eventQueue.push(event);\n    }\n\n    this.tracks.push(eventQueue);\n    this.plainTracks.push(plainQueue);\n  };\n};\n"],"sourceRoot":""}